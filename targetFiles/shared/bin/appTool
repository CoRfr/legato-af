#!/bin/sh

# Starts, stops, restarts, installs and uninstalls Legato applications.

LEGATO_ROOT=/opt/legato

APPS_ROOT=$LEGATO_ROOT/apps
APPS_BACKUP_ROOT=$LEGATO_ROOT/appsBackup
APPS_SYS_CFG_BACKUP=sysCfgBack
APPS_CFG_BACKUP=cfgBack
SANDBOX_ROOT=/tmp/legato/sandboxes
PREINSTALL_SCRIPT_RELATIVE_PATH=script/pre-install
POSTINSTALL_SCRIPT_RELATIVE_PATH=script/post-install

ACTION=$1
APP_NAME=$(basename "$2" | sed 's/\.[^.]*$//')
UNPACKED_APP_DIR_PATH=${3%/}

exitCode=0

# used to carry the result of GetAppStatus
appStatus="unknown"

# Make sure /usr/local/bin is in the path.
export PATH=/usr/local/bin:$PATH


# Check if ps supports arguments.  If so, we need to run "ps aux" to be able
# to see the supervisor process if it is running.  Otherwise, we just run "ps".
PS='ps aux'
if ! $PS > /dev/null 2>&1
then
    PS=ps
fi


PrintUsage()
{
    echo
    echo "USAGE: `basename $0` install APP_NAME UNPACKED_APP_DIR_PATH"
    echo "   or: `basename $0` remove APP_NAME"
    echo "   or: `basename $0` restore APP_NAME"
    echo
    echo "In the first form, app will be installed from specified path."
    echo
    echo "In the second form, specified app will be removed."
    echo
    echo "In the third form, specified app will be restored if any backup is available."
    echo
}


ListApps()
{
    appCtrl "list"
}


AppStatus()
{
    if [ $# -eq 0 ]
    then
        appCtrl "status"
        exit $?
    fi

    while [ $# -ge 1 ]
    do
        appCtrl "status" "$1"

        if [ $? -ne 0 ]
        then
            exit 1
        fi

        shift
    done
}


StartApp()
# Takes a list of applications as arguments.
{
    while [ $# -ge 1 ]
    do
        echo "Starting app '$1'..." 1>&2

        appCtrl "start" "$1"

        if [ $? -ne 0 ]
        then
            exitCode=1
        else
            echo "DONE" 1>&2
        fi

        shift
    done
}


StopApp()
# Takes a list of applications as arguments.
{
    while [ $# -ge 1 ]
    do
        echo "Stopping app '$1'..." 1>&2

        appCtrl "stop" "$1"

        if [ $? -ne 0 ]
        then
            exitCode=1
        else
            echo "DONE" 1>&2
        fi

        shift
    done
}


InstallApp()
# Takes a single application name as its only argument.
{
    appName="$1"
    unpackedAppDirPath="$2"
    preInstallScriptPath=$unpackedAppDirPath/$PREINSTALL_SCRIPT_RELATIVE_PATH

    # Check whether any pre-install script exists. If yes pass it to install-hook.
    if [ -f "$preInstallScriptPath" ]
    then
        echo "Running pre-install script" 1>&2

        install-hook "$preInstallScriptPath"

        if [ $? -ne 0 ]
        then
            echo "***Error: PreInstall script failed" 1>&2
            return 1
        fi
    fi

    (
        # Move the install directory of the app into the back up directory.
        ( mv "$unpackedAppDirPath"  "$APPS_ROOT/$appName") &&
        # Install the application's configuration into the root user's configuration tree.
        ( appCfgInstall "$appName" ) &&

        # Create a user account for the app.
        ( appUserAdd "$appName" ) &&

        # Set the permissions for the app.
        ( appSetFilePermissions "$appName" ) &&

        # Load the latest IPC binding configuration into the Service Directory.
        ( sdir load )
    )

    if [ $? -ne 0 ]
    then
        rm -rf "$APPS_ROOT/$appName"
        echo "FAILED" 1>&2
        return 1
    else
        # Check whether any post-install script exists. If yes pass it to install-hook.
        postInstallScriptPath=$APPS_ROOT/$appName/$POSTINSTALL_SCRIPT_RELATIVE_PATH

        if [ -f "$postInstallScriptPath" ]
        then
            echo "Running post-install script" 1>&2

            install-hook "$postInstallScriptPath"

            if [ $? -ne 0 ]
            then
                rm -rf "$APPS_ROOT/$appName"
                echo "***Error: PostInstall script failed" 1>&2
                return 1
            fi
        fi
        echo "DONE" 1>&2
    fi
}


RemoveApp()
# Takes a list of applications as arguments.
{
    while [ $# -ge 1 ]
    do
        echo "Removing app '$1'..." 1>&2

        rm -rf "$APPS_ROOT/$1"

        if [ $? -ne 0 ]
        then
            exitCode=1
            echo "***Error: Couldn't remove installation directory." 1>&2
        fi

        # In case an earlier removal process was interrupted or someone manually deleted
        # the app's install directory, even if it doesn't look like it's installed,
        # delete the app's configuration and user account.
        appCfgRemove "$1"
        if [ $? -ne 0 ]
        then
            exitCode=1
            echo "***Error: Couldn't remove configuration data." 1>&2
        fi

        appUserRemove "$1"
        if [ $? -ne 0 ]
        then
            exitCode=1
            echo "***Error: Couldn't remove user account." 1>&2
        fi


        # Load the latest IPC binding configuration into the Service Directory.
        sdir load
        if [ $? -ne 0 ]
        then
            exitCode=1
            echo "***Error: Couldn't update Service Directory's IPC bindings." 1>&2
        fi

        shift
    done
}

# Before we do any work, see if the framework is running.
$PS | grep supervisor | grep -v grep > /dev/null
if [ $? -ne 0 ]
then
    echo "***Error: The legato framework is not running. Please start it before proceeding." 1>&2
    exit 1
fi

# Use the new appCtrl status to determine what state the app is currently in.
# Sets appStatus top 'not_installed' 'stopped' 'running' or 'unknown'
GetAppStatus()
{
    case $(appCtrl "status" "$1") in

    *installed*)
        appStatus='not_installed'
        ;;
    *stopped*)
        appStatus='stopped'
        ;;
    *running*)
        appStatus='running'
        ;;
    *)
        appStatus='unknown'
        ;;
    esac
}

# Check that something was given as an app name.
CheckAppNameAvail()
{
    if [ "$APP_NAME" = "" ]
    then
        echo "***Error: Missing application name." 1>&2
        exit 1
    fi
}

# Back up the specified app.  Takes a single application name as its only argument.
BackupApp()
{
    appName=$1

    # Delete what's in the back up app directory first.
    RemoveBackupApp $appName

    # Move the install directory of the app into the back up directory.
    ( mv $APPS_ROOT/$appName $APPS_BACKUP_ROOT/$appName ) &&

    # Back up the app's system config.
    ( config export apps/$appName $APPS_BACKUP_ROOT/$appName/$APPS_SYS_CFG_BACKUP ) &&

    # Back up the app's config.
    config export $appName:/ $APPS_BACKUP_ROOT/$appName/$APPS_CFG_BACKUP

    if [ $? -ne 0 ]
    then
        echo "***Error: FAILED to create back-up of app $appName" 1>&2
    fi
}

# Removes the back-up version of the specified app if it exists.  Takes a single application name as
# its only argument.
RemoveBackupApp()
{
    appName=$1

    rm -fr $APPS_BACKUP_ROOT/$appName > /dev/null 2>&1
}

# Restores the back-up version of the specified app if it exists.  Takes a single application name
# as its only argument.
RestoreBackupApp()
{
    appName=$1

    if [ -d "$APPS_BACKUP_ROOT/$appName" ]
    then
        echo "Restoring original version of app." 1>&2

        # Delete what's in the app directory first.
        ( rm -rf $APPS_ROOT/$appName > /dev/null 2>&1 ) &&

        # Move the install directory of the app back into the app directory.
        ( mv $APPS_BACKUP_ROOT/$appName $APPS_ROOT/$appName ) &&

        # Restore the config settings.
        ( config import apps/$appName $APPS_ROOT/$appName/$APPS_SYS_CFG_BACKUP ) &&
        ( config import $appName:/ $APPS_ROOT/$appName/$APPS_CFG_BACKUP ) &&

        # Delete the the config backups.
        ( rm $APPS_ROOT/$appName/$APPS_SYS_CFG_BACKUP ) &&
        ( rm $APPS_ROOT/$appName/$APPS_CFG_BACKUP ) &&

        # Create a user account for the app.
        ( appUserAdd $appName ) &&

        # Load the latest IPC binding configuration into the Service Directory.
        ( sdir load ) &&

        ( RemoveBackupApp $appName)
    fi

    if [ $? -ne 0 ]
    then
        echo "***Error: FAILED to restore original version of app $appName" 1>&2
        return 1
    else
        echo "DONE" 1>&2
    fi
}

# Check to see if the given application is marked as manual start or auto start.
# Return 1 if manual, 0 if auto start.
IsAppAutoStart()
{
    appName=$1
    isManualStart=`config get "apps/$appName/startManual"`

    if [ "$isManualStart" = "true" ]
    then
        return 1
    fi

    return 0
}


# Check if they are asking for help.
if [ "$1" = "-h" -o "$1" = "help" -o "$1" = "--help" ]
then
    PrintUsage 1>&2
    exit 0
fi

# Check that the application root directory exists.
if ! [ -d "$APPS_ROOT" ]
then
    mkdir -p "$APPS_ROOT"
fi

# Check that the application backup root directory exists.
if ! [ -d "$APPS_BACKUP_ROOT" ]
then
    mkdir -p "$APPS_BACKUP_ROOT"
fi

# Build the list of applications to operate on.
APP_LIST=
if [ "$APP_NAME" = "*" ]
then
    APP_LIST=`appCtrl list`
    if [ "$APP_LIST" = "" ]
    then
        echo "There are no applications currently installed." 1>&2
        exit 0
    fi
else
    shift

    for arg in "$@"
    do
        APP_LIST="$APP_LIST $(basename $arg | sed 's/\.[^.]*$//')"
    done
fi

case "$ACTION" in

install)
    CheckAppNameAvail

    # Only one, specific application name allowed.
    if [ "$APP_NAME" = "*" ]
    then
        echo "***ERROR: One specific application name must be provided for install." 1>&2
        PrintUsage 1>&2
        exit 1
    fi

    if [ "$UNPACKED_APP_DIR_PATH" = "" ]
    then
        echo "***ERROR: Missing app package path." 1>&2
        PrintUsage 1>&2
        exit 1
    fi

    if ! [ -d "$UNPACKED_APP_DIR_PATH" ]
    then
        echo "***ERROR: Provided wrong app package path: $UNPACKED_APP_DIR_PATH." 1>&2
        exit 1
    fi

    # In case it's already installed, stop it and remove it first.
    GetAppStatus $APP_NAME

    if [[ $appStatus == "running" ]]
    then
        StopApp $APP_NAME
        appStatus='stopped'
    fi

    if [[ $appStatus == "stopped" ]]
    then
        BackupApp $APP_NAME
        RemoveApp $APP_NAME
        appStatus='not_installed'
    fi

    if [[ $appStatus == "not_installed" ]]
    then
        InstallApp "$APP_NAME" "$UNPACKED_APP_DIR_PATH"

        installStatus=$?

        if [ $installStatus -eq 0 ]
        then

            IsAppAutoStart $APP_NAME
            isAuto=$?

            if [ $isAuto -eq 0 ]
            then
                StartApp $APP_NAME
            fi

            RemoveBackupApp $APP_NAME

        else
            RestoreBackupApp $APP_NAME
        fi

        exit $installStatus
    else
        echo "***Error: Install $APP_NAME failed. Unknown error." 1>&2
        # in the future we may use different return codes for different errors
        exitCode=1
    fi

    ;;

remove)
    CheckAppNameAvail

    # loop through the list giving each app individual treatment
    # preserve any non-zero exit code
    for APP_NAME in $APP_LIST
    do
        GetAppStatus $APP_NAME

        echo "App '$APP_NAME' is $appStatus" 1>&2

        if [[ $appStatus == "running" ]]
        then
            StopApp $APP_NAME
            appStatus='stopped'
        fi

        if [[ $appStatus == "stopped" ]]
        then
            RemoveApp $APP_NAME
        elif [[ $appStatus == "not_installed" ]]
        then
            echo "***Error: $APP_NAME is not installed. Cannot remove" 1>&2
            exitCode=1
        else
            echo "***Error: Remove $APP_NAME failed. Unknown error." 1>&2
            # in the future we may use different return codes for different errors
            exitCode=1
        fi
    done
    ;;

restore)
    CheckAppNameAvail

    # Only one, specific application name allowed.
    if [ "$APP_NAME" = "*" ]
    then
        echo "***ERROR: One specific application name must be provided for restoring." 1>&2
        PrintUsage 1>&2
        exit 1
    fi

    echo "Restoring APP: $APP_NAME" 1>&2
    # Now call the restoring the app from backup
    RestoreBackupApp $APP_NAME
    exitCode=$?
    ;;

*)
    PrintUsage 1>&2
    exit 1
    ;;

esac

exit $exitCode
