//--------------------------------------------------------------------------------------------------
/**
 * @page c_mcc Modem Call Control
 *
 * @ref le_mcc_interface.h "API Reference"
 *
 * <HR>
 *
 * The Modem Call Control (mcc) API functions of this API are provided by the @b modemService
 * service.
 *
 * @section le_mcc_binding IPC interfaces binding
 *
 * Here's a code sample binding to modem services:
 * @verbatim
   bindings:
   {
      clientExe.clientComponent.le_mcc -> modemService.le_mcc
   }
   @endverbatim
 *
 * @section le_mcc_starting_a_call Starting a Call
 *
 * To initiate a call, create a new call object with a destination telephone
 * number calling the le_mcc_Create() function.
 *
 * le_mcc_Start() must still initiate the call when ready.
 *
 * The le_mcc_Start() function initiates a call attempt (it's asynchronous because it can take
 * time for a call to connect).
 *
 * It's essential to register a handler function to get the call events. Use
 * le_mcc_AddCallEventHandler() API to install that handler function. The handler will be
 * called for all calls' events (incoming and outgoing).
 *
 * The le_mcc_RemoveCallEventHandler() API uninstalls the handler function.
 *
 * The following APIs can be used to manage incoming or outgoing calls:
 * - le_mcc_GetTerminationReason() - termination reason.
 * - le_mcc_GetPlatformSpecificTerminationCode() - the platform specific termination code (refer
 * to your platform documentation for further details).
 * - le_mcc_IsConnected() - connection status.
 * - le_mcc_GetRemoteTel() - displays remote party telephone number associated with the call.
 * - le_mcc_HangUp() will disconnect this call.
 *
 * When finished with the call object, call le_mcc_Delete() to free all the allocated resources
 * associated with the object.
 *
 * This code example uses @c CallAndPlay() to dial a phone number, and if successful, play
 * a sound file. Once the file has played, the call hangs up.
 *
 * @code
 *
 * typedef struct
 * {
 *     le_mcc_CallRef_t             callRef;
 *     char                         filePath[MAX_FILE_PATH_BYTES];
 *     le_mcc_CallEventHandlerRef_t eventHandlerRef;
 * }
 * PlayContext_t;
 *
 * void CallAndPlay
 * (
 *     const char* destinationTelPtr,
 *     const char* filePathPtr
 * )
 * {
 *     PlayContext_t* contextPtr = (PlayContext_t*)le_mem_ForceAlloc(PlayContextPoolRef);
 *
 *     le_str_Copy(contextPtr->filePath, filePathPtr, sizeof(contextPtr->filePath), NULL);
 *
 *     contextPtr->callRef = le_mcc_Create(destinationTelPtr);
 *
 *     contextPtr->eventHandlerRef = le_mcc_AddCallEventHandler(MyCallEventHandler,
 *                                                                   contextPtr);
 *
 *     le_mcc_Start(contextPtr->callRef);
 * }
 *
 *
 * static void MyCallEventHandler
 * (
 *     le_mcc_CallRef_t callRef,
 *     le_mcc_Event_t   event,
 *     void*            contextPtr
 * )
 * {
 *     PlayContext_t*      myContextPtr = (PlayContext_t*)contextPtr;
 *
 *     switch (event)
 *     {
 *         case LE_MCC_EVENT_CONNECTED:
 *             {
 *                  [...]
                    le_audio_PlayFile(FileAudioRef, AudioFileFd);
                    [...]
 *             }
 *             break;
 *
 *         case LE_MCC_EVENT_TERMINATED:
 *             le_mcc_Delete(callRef);
 *             // I don't release the Profile for further use
 *
 *             le_mcc_RemoveCallEventHandler(contextPtr->eventHandlerRef);
 *
 *             le_mem_Release(myContextPtr);
 *             break;
 *     }
 * }
 *
 *
 * static void MyAudioFinishedHandler
 * (
 *     le_audio_PlayComplete reason,
 *     void*                 contextPtr
 * )
 * {
 *     PlayContext_t* myContextPtr = (PlayContext_t*)contextPtr;
 *
 *     le_mcc_HangUp(myContextPtr->callRef);  // This will trigger a TERMINATED event.
 * }
 *
 *
 * @endcode
 *
 *
 * @section le_mcc_answering_a_call Answering a call
 *
 * Receiving calls is similar sending calls. Add a handler through le_mcc_AddCallEventHandler()
 * to be notified of incoming calls.
 *
 * To answer, call le_mcc_Answer(). To reject it, call le_mcc_HangUp().
 *
 * This code example uses InstallAutomaticAnswer() to install a call event handler
 * that  automatically answers incoming calls. The handler function verifies the incoming
 * call is permitted (through a predefined list), and then decides whether to answer or terminate
 * it.
 *
 * @code
 *
 * static le_audio_ConnectorRef_t AudioRxConnectorRef = NULL;
 * static le_audio_ConnectorRef_t AudioTxConnectorRef = NULL;
 * static le_audio_StreamRef_t MicRef = NULL;
 * static le_audio_StreamRef_t SpeakerRef = NULL;
 * static le_audio_StreamRef_t CallRxAudioRef = NULL;
 * static le_audio_StreamRef_t CallTxAudioRef = NULL;
 *
 * void InstallAutomaticAnswer
 * (
 *     void
 * )
 * {
 *     le_mcc_AddCallEventHandler(   MyVoiceCallEventHandler,
 *                                        contextPtr);
 * }
 *
 *
 * static void MyVoiceCallEventHandler
 * (
 *     le_mcc_CallRef_t callRef,
 *     le_mcc_Event_t   event,
 *     void*            contextPtr
 * )
 * {
 *     char                tel[TEL_NMBR_MAX_BYTES];
 *
 *     switch (event)
 *     {
 *         case LE_MCC_EVENT_INCOMING:
 *             {
 *                 le_mcc_GetRemoteTel(callRef, &tel, sizeof(tel));
 *                 if (IsAnAuthorizedIncomingCall(tel) == TRUE)
 *                 {
 *                     SpeakerRef = le_audio_OpenSpeaker();
 *                     CallRxAudioRef = le_audio_OpenModemVoiceRx();
 *                     MicRef = le_audio_OpenMic();
 *                     CallTxAudioRef = le_audio_OpenModemVoiceTx();
 *
 *                     AudioRxConnectorRef = le_audio_CreateConnector();
 *                     AudioTxConnectorRef = le_audio_CreateConnector();
 *
 *                     le_audio_Connect(AudioRxConnectorRef, speakerRef);
 *                     le_audio_Connect (AudioRxConnectorRef, callRxAudioRef);
 *
 *                     le_audio_Connect(AudioTxConnectorRef, micRef);
 *                     le_audio_Connect (AudioTxConnectorRef, callTxAudioRef);
 *
 *                     le_mcc_Answer(callRef);
 *                 }
 *                 else
 *                 {
 *                     // Reject the incoming call
 *                     le_mcc_HangUp(callRef);
 *                 }
 *              }
 *          break;
 *
 *          case LE_MCC_EVENT_TERMINATED:
 *              le_audio_Disconnect(micRef);
 *              le_audio_Disconnect(speakerRef);
 *              le_audio_Disconnect(AudioRxConnectorRef);
 *              le_audio_Disconnect(AudioTxConnectorRef);
 *              le_mcc_Delete(callRef);
 *          break;
 *      }
 *  }
 *
 * @endcode
 *
 *
 * @section le_mcc_ending_all_call Ending all calls
 *
 * A special function can be used to hang-up all the ongoing calls: le_mcc_HangUpAll().
 * This function can be used to hang-up any calls that have been initiated through another client
 * like AT commands.
 *
 * @section le_mcc_ss Supplementary service.
 *
 * Calling Line Identification Restriction (CLIR) can be activated or deactivated by
 *  le_mcc_SetCallerIdRestrict API. The status is independent for each call object reference.
 *  Status can be read with the le_mcc_GetCallerIdRestrict() API.
 * Default value is LE_OFF (Enable presentation of own phone number to remote).
 *
 * @todo Other Supplementary services will be available in a future release. Create simpler examples.
 *
 * <HR>
 *
 * Copyright (C) Sierra Wireless Inc. Use of this work is subject to license.
 */
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
/**
 * @file le_mcc_interface.h
 *
 * Legato @ref c_mcc include file.
 *
 * Copyright (C) Sierra Wireless Inc. Use of this work is subject to license.
 */
//--------------------------------------------------------------------------------------------------

USETYPES le_mdmDefs.api;

//--------------------------------------------------------------------------------------------------
/**
 *  Enumeration of the possible events that may be reported to a call event handler.
 */
//--------------------------------------------------------------------------------------------------
ENUM Event
{
    EVENT_SETUP,       ///< Call is being set up.
    EVENT_INCOMING,    ///< Incoming call attempt (new call).
    EVENT_ORIGINATING, ///< Outgoing call attempt.
    EVENT_ALERTING,    ///< Far end is now alerting its user (outgoing call).
    EVENT_EARLY_MEDIA, ///< Callee has not accepted the call, but a media stream
                       ///< is available.
    EVENT_CONNECTED,   ///< Call has been established, and is media is active.
    EVENT_TERMINATED,  ///< Call has terminated.
    EVENT_ON_HOLD,     ///< Remote party has put the call on hold.
    EVENT_TRANSFERED   ///< Remote party transferred or forwarded the call.
};


//--------------------------------------------------------------------------------------------------
/**
 *  Enumeration of the possible reasons for call termination.
 */
//--------------------------------------------------------------------------------------------------
ENUM TerminationReason
{
    TERM_LOCAL_ENDED,              ///< Local party ended the call (Normal Call Clearing).
    TERM_REMOTE_ENDED,             ///< Remote party ended the call (Normal Call Clearing).
    TERM_NETWORK_FAIL,             ///< Network could not complete the call.
    TERM_UNASSIGNED_NUMBER,                                 ///< cf. 3GPP 24.008 Annex H
    TERM_NO_ROUTE_TO_DESTINATION,                           ///< cf. 3GPP 24.008 Annex H
    TERM_CHANNEL_UNACCEPTABLE,                              ///< cf. 3GPP 24.008 Annex H
    TERM_OPERATOR_DETERMINED_BARRING,                       ///< cf. 3GPP 24.008 Annex H
    TERM_USER_BUSY,                                         ///< cf. 3GPP 24.008 Annex H
    TERM_NO_USER_RESPONDING,                                ///< cf. 3GPP 24.008 Annex H
    TERM_USER_ALERTING_NO_ANSWER,                           ///< cf. 3GPP 24.008 Annex H
    TERM_CALL_REJECTED,                                     ///< cf. 3GPP 24.008 Annex H
    TERM_NUMBER_CHANGED,                                    ///< cf. 3GPP 24.008 Annex H
    TERM_PREEMPTION,                                        ///< cf. 3GPP 24.008 Annex H
    TERM_DESTINATION_OUT_OF_ORDER,                          ///< cf. 3GPP 24.008 Annex H
    TERM_INVALID_NUMBER_FORMAT,                             ///< cf. 3GPP 24.008 Annex H
    TERM_FACILITY_REJECTED,                                 ///< cf. 3GPP 24.008 Annex H
    TERM_RESP_TO_STATUS_ENQUIRY,                            ///< cf. 3GPP 24.008 Annex H
    TERM_NORMAL_UNSPECIFIED,                                ///< cf. 3GPP 24.008 Annex H
    TERM_NO_CIRCUIT_OR_CHANNEL_AVAILABLE,                   ///< cf. 3GPP 24.008 Annex H
    TERM_NETWORK_OUT_OF_ORDER,                              ///< cf. 3GPP 24.008 Annex H
    TERM_TEMPORARY_FAILURE,                                 ///< cf. 3GPP 24.008 Annex H
    TERM_SWITCHING_EQUIPMENT_CONGESTION,                    ///< cf. 3GPP 24.008 Annex H
    TERM_ACCESS_INFORMATION_DISCARDED,                      ///< cf. 3GPP 24.008 Annex H
    TERM_REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE,        ///< cf. 3GPP 24.008 Annex H
    TERM_RESOURCES_UNAVAILABLE_OR_UNSPECIFIED,              ///< cf. 3GPP 24.008 Annex H
    TERM_QOS_UNAVAILABLE,                                   ///< cf. 3GPP 24.008 Annex H
    TERM_REQUESTED_FACILITY_NOT_SUBSCRIBED,                 ///< cf. 3GPP 24.008 Annex H
    TERM_INCOMING_CALLS_BARRED_WITHIN_CUG,                  ///< cf. 3GPP 24.008 Annex H
    TERM_BEARER_CAPABILITY_NOT_AUTH,                        ///< cf. 3GPP 24.008 Annex H
    TERM_BEARER_CAPABILITY_UNAVAILABLE,                     ///< cf. 3GPP 24.008 Annex H
    TERM_SERVICE_OPTION_NOT_AVAILABLE,                      ///< cf. 3GPP 24.008 Annex H
    TERM_ACM_LIMIT_EXCEEDED,                                ///< cf. 3GPP 24.008 Annex H
    TERM_BEARER_SERVICE_NOT_IMPLEMENTED,                    ///< cf. 3GPP 24.008 Annex H
    TERM_REQUESTED_FACILITY_NOT_IMPLEMENTED,                ///< cf. 3GPP 24.008 Annex H
    TERM_ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE,         ///< cf. 3GPP 24.008 Annex H
    TERM_SERVICE_OR_OPTION_NOT_IMPLEMENTED,                 ///< cf. 3GPP 24.008 Annex H
    TERM_INVALID_TRANSACTION_IDENTIFIER,                    ///< cf. 3GPP 24.008 Annex H
    TERM_USER_NOT_MEMBER_OF_CUG,                            ///< cf. 3GPP 24.008 Annex H
    TERM_INCOMPATIBLE_DESTINATION,                          ///< cf. 3GPP 24.008 Annex H
    TERM_INVALID_TRANSIT_NW_SELECTION,                      ///< cf. 3GPP 24.008 Annex H
    TERM_SEMANTICALLY_INCORRECT_MESSAGE,                    ///< cf. 3GPP 24.008 Annex H
    TERM_INVALID_MANDATORY_INFORMATION,                     ///< cf. 3GPP 24.008 Annex H
    TERM_MESSAGE_TYPE_NON_IMPLEMENTED,                      ///< cf. 3GPP 24.008 Annex H
    TERM_MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE,   ///< cf. 3GPP 24.008 Annex H
    TERM_INFORMATION_ELEMENT_NON_EXISTENT,                  ///< cf. 3GPP 24.008 Annex H
    TERM_CONDITONAL_IE_ERROR,                               ///< cf. 3GPP 24.008 Annex H
    TERM_MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE,        ///< cf. 3GPP 24.008 Annex H
    TERM_RECOVERY_ON_TIMER_EXPIRY,                          ///< cf. 3GPP 24.008 Annex H
    TERM_PROTOCOL_ERROR_UNSPECIFIED,                        ///< cf. 3GPP 24.008 Annex H
    TERM_INTERWORKING_UNSPECIFIED,                          ///< cf. 3GPP 24.008 Annex H
    TERM_PLATFORM_SPECIFIC,                                 ///< Platform specific code.
    TERM_UNDEFINED                                          ///< Undefined reason.
};


//--------------------------------------------------------------------------------------------------
/**
 *  Reference type for managing active calls.
 */
//--------------------------------------------------------------------------------------------------
REFERENCE Call;

//--------------------------------------------------------------------------------------------------
/**
 * Create a call reference.
 *
 * @note Return NULL if call reference can't be created
 *
 * @note If destination number is too long (max LE_MDMDEFS_PHONE_NUM_MAX_LEN digits),
 * it is a fatal error, the function will not return.
 *
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Call Create
(
    string   phoneNumPtr[le_mdmDefs.PHONE_NUM_MAX_LEN]   IN ///< The target number we are going to
                                                            ///< call.
);

//--------------------------------------------------------------------------------------------------
/**
 * Call to free up a call reference.
 *
 * @return
 *     - LE_OK        The function succeed.
 *     - LE_NOT_FOUND The call reference was not found.
 *     - LE_FAULT      The function failed.
 *
 *
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t Delete
(
    Call callRef IN  ///< The call object to free.
);

//--------------------------------------------------------------------------------------------------
/**
 * Start a call attempt.
 *
 * Asynchronous due to possible time to connect.
 *
 * As the call attempt proceeds, the profile's registered call event handler receives events.
 *
 * @return LE_OK            Function succeed.
 *
 * * @note As this is an asynchronous call, a successful only confirms a call has been
 *       started. Don't assume a call has been successful yet.
 *
 * @note If the caller is passing a bad pointer into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t Start
(
    Call callRef IN  ///< Reference to the call object.
);

//--------------------------------------------------------------------------------------------------
/**
 * Allow the caller to know if the given call is actually connected or not.
 *
 * @return TRUE if the call is connected, FALSE otherwise.
 *
 * @note If the caller is passing a bad pointer into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION bool IsConnected
(
    Call callRef IN ///< The call reference to read.
);

//--------------------------------------------------------------------------------------------------
/**
 * Read out the remote party telephone number associated with the call.
 *
 * Output parameter is updated with the telephone number. If the Telephone number string length exceeds
 * the value of 'len' parameter, the LE_OVERFLOW error code is returned and 'telPtr' is used until
 * 'len-1' characters and a null-character is implicitly appended at the end of 'telPtr'.
 * Note that 'len' sould be at least equal to LE_MDMDEFS_PHONE_NUM_MAX_BYTES, otherwise LE_OVERFLOW
 * error code will be common.
 *
 * @return LE_OVERFLOW      The Telephone number length exceed the maximum length.
 * @return LE_OK            The function succeeded.
 *
 * @note If the caller is passing a bad pointer into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t GetRemoteTel
(
    Call     callRef IN,                                 ///<  The call reference to read from.
    string  telPtr[le_mdmDefs.PHONE_NUM_MAX_LEN] OUT    ///< The telephone number string.
);

//--------------------------------------------------------------------------------------------------
/**
 * Called to get the termination reason.
 *
 * @return The termination reason.
 *
 * @note If the caller is passing a bad pointer into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION TerminationReason GetTerminationReason
(
    Call callRef IN ///< The call reference to read from.
);

//--------------------------------------------------------------------------------------------------
/**
 * Called to get the platform specific termination code.
 *
 * @return The platform specific termination code.
 *
 * @note If the caller is passing a bad pointer into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION int32 GetPlatformSpecificTerminationCode
(
    Call callRef IN ///< The call reference to read from.
);

//--------------------------------------------------------------------------------------------------
/**
 *  Answers incoming call.
 *
 * @return LE_TIMEOUT       No response was received from the Modem.
 * @return LE_OK            The function succeeded.
 *
 * @note If the caller is passing a bad pointer into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t Answer
(
    Call callRef IN ///< The call reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * Disconnect, or hang up, the specifed call. Any active call handlers
 * will be notified.
 *
 * @return LE_TIMEOUT       No response was received from the Modem.
 * @return LE_OK            Function succeeded.
 *
 * @note If the caller is passing a bad pointer into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t HangUp
(
    Call callRef IN ///< The call to end.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function will disconnect, or hang up all the ongoing calls. Any active call handlers will
 * be notified.
 *
 * @return LE_FAULT         The function failed.
 * @return LE_TIMEOUT       No response was received from the Modem.
 * @return LE_OK            The function succeeded.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t HangUpAll
(
);

//--------------------------------------------------------------------------------------------------
/**
 * This function return the Calling Line Identification Restriction (CLIR) status on the specific
 *  call.
 *
 * The output parameter is updated with the CLIR status.
 *    - LE_ON  Disable presentation of own phone number to remote.
 *    - LE_OFF Enable presentation of own phone number to remote.
 *
 * @return
 *    - LE_OK        The function succeed.
 *    - LE_NOT_FOUND The call reference was not found.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t GetCallerIdRestrict
(
    Call callRef IN, ///< The call reference.
    le_onoff_t clirStatusPtr OUT        ///< the Calling Line Identification Restriction (CLIR) status
);

//--------------------------------------------------------------------------------------------------
/**
 * This function set the Calling Line Identification Restriction (CLIR) status on the specific call.
 * Default value is LE_OFF (Enable presentation of own phone number to remote).
 *
 * @return
 *     - LE_OK        The function succeed.
 *     - LE_NOT_FOUND The call reference was not found.
 *
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t SetCallerIdRestrict
(
    Call callRef IN, ///< The call reference.
    le_onoff_t clirStatus IN         ///< The Calling Line Identification Restriction (CLIR) status.
);



//--------------------------------------------------------------------------------------------------
/**
 * Handler for call state changes.
 *
 * @note The callRef has to be deleted using le_mcc_Delete() when LE_MCC_TERMINATED event
 * is received, except if is has to be used for a future usage (with le_mcc_profile handler for
 * instance, or dialing again the same number).
 *
 */
//--------------------------------------------------------------------------------------------------
HANDLER CallEventHandler
(
    Call callRef IN, ///< The call reference.
    Event  event    ///< Call event.
);

//--------------------------------------------------------------------------------------------------
/**
 * Register an event handler that will be notified when an call's event occurs.
 *
 * @return A reference to the new event handler object.
 *
 * @note It is a fatal error if this function does succeed.  If this function fails, it will not
 *       return.
 *
 */
//--------------------------------------------------------------------------------------------------
EVENT CallEvent
(
    handler CallEventHandler
);


