/**
 * @page c_audio Audio
 *
 * @ref le_audio_interface.h "API Reference"
 *
 * <HR>
 *
 * The Audio API handles audio interfaces including play or listen supported formats.
 *
 * A Legato device can use several audio interfaces. You choose the input and output
 * interfaces to tie together. The Audio stream-related to a particular interface is
 * represented with an 'Audio Stream Reference'.
 *
 * You can create your own audio path by connecting several audio streams together using
 * audio connectors.
 *
 * An audio path can support more than two audio interfaces. You can have a basic output audio
 * path of a voice call to connect the Modem Voice Received interface with the Speaker
 * interface, and at the same time, the Modem Voice Received interface can be also connected to a
 * Recorder Device interface.
 *
 * @section le_audio_configuration Configure the Audio
 *
 * The audio profile can be set with the le_audio_SetProfile() function. The pre-configured
 * profiles are defined with @c le_audio_Profile_t enumeration type.
 *
 * @warning Ensure to check the list of supported audio profiles for your specific platform.
 *
 * The audio profile in use can be retrieved with the le_audio_GetProfile() function.
 *
 * Then, the following functions let you enable or disable the audio settings on the selected audio
 * interface:
 * - le_audio_EnableNoiseSuppressor()/le_audio_DisableNoiseSuppressor(): Noise Suppressor.
 * - le_audio_EnableEchoCanceller()/ le_audio_DisableEchoCanceller(): Echo Canceller.
 * - le_audio_EnableFirFilter()/ le_audio_DisableFirFilter(): downlink FIR Filter (Finite Impulse
 *   Response).
 * - le_audio_EnableIirFilter()/ le_audio_DisableIirFilter(): downlink IIR Filter (Infinite Impulse
 *   Response).
 * - le_audio_EnableAutomaticGainControl()/ le_audio_DisableAutomaticGainControl(): automatic
 *   gain on the selected audio stream.
 *
 * @section le_audio_interfaces Open/Close an Audio Interface
 *
 * The following functions let you select the desired interface:
 * - le_audio_OpenMic(): returns an Audio Stream Reference of the analog audio signal coming from
 *                       the microphone input.
 * - le_audio_OpenSpeaker(): returns an Audio Stream Reference of the analog audio signal routed
 *                           to the Speaker output.
 * - le_audio_OpenUsbRx(): returns an Audio Stream Reference of the digitized audio signal coming
 *                         from an external device connected via USB Audio Class.
 * - le_audio_OpenUsbTx(): returns an Audio Stream Reference of the digitized audio signal routed
 *                         to an external device connected via USB Audio Class.
 * - le_audio_OpenPcmRx(): it returns an Audio Stream Reference of the digitized audio signal
 *                            coming from an external device connected via the PCM interface.
 * - le_audio_OpenPcmTx(): it returns an Audio Stream Reference of the digitized audio signal
 *                            routed to an external device connected via the PCM interface.
 * - le_audio_OpenI2sRx(): it returns an Audio Stream Reference of the digitized audio signal
 *                            coming from an external device connected via the I2S interface.
 * - le_audio_OpenI2sTx(): it returns an Audio Stream Reference of the digitized audio signal
 *                            routed to an external device connected via the I2S interface.
 * - le_audio_OpenModemVoiceRx(): returns an Audio Stream Reference of the digitized audio signal
 *                                coming from a voice call. The audio format is negotiated with the
 *                                network when the call is established.
 * - le_audio_OpenModemVoiceTx(): returns an Audio Stream Reference of the digitized audio signal
 *                                routed to a voice call. The audio format is negotiated with the
 *                                network when the call is established.
 *
 * Multiple users can own the same stream at the same time.
 *
 * le_audio_GetDefaultPcmTimeSlot() can be called to get the default PCM time slot used on the
 * current platform.
 *
 * le_audio_GetDefaultI2sMode() can be called to get the default I2s channel mode slot used on
 * the current platform.
 *
 * le_audio_GetFormat() can be called to get the audio format of an input or output stream.
 *
 * Call le_audio_Close() to release it. If
 * several users own the same, corresponding stream reference, the interface will
 * close only after the last user releases the audio stream.
 *
 * You can configure the PCM interface with the le_audio_SetPcmSamplingRate(),
 * le_audio_SetPcmSamplingResolution() and le_audio_SetPcmCompanding() functions.
 * This function must be called before activating an audio path with the PCM interface, in other
 * words you must call this function before connecting the PCM Stream to a connector.
 *
 * In addition, the le_audio_GetPcmSamplingRate(), le_audio_GetPcmSamplingResolution() and
 * le_audio_GetPcmCompanding() functions allows you to retrieve the PCM interface configuration.
 *
 * @section le_audio_streams Control an Audio Stream
 *
 * Once the users get an Audio Stream reference, they can control it with the following functions:
 *
 * - le_audio_SetGain(): allows the user to adjust the gain of an audio stream (0 means 'muted',
 *                          100 is the maximum gain value).
 * - le_audio_GetGain(): allows the User to retrieve the gain of an audio stream (0 means
 *                          'muted', 100 is the maximum gain value).
 * - le_audio_Mute(): allows the user to mute an audio stream.
 * - le_audio_Unmute(): allows the user to unmute an audio stream.
 *
 * @note The hardware may or may not support the full 0-100 resolution, and if you want to see what
 * was actually set call le_audio_GetGain() after le_audio_SetGain() to get the real value.
 *
 * The users have also the possibility to register a handler function to catch some stream-related
 * notifications such as errors or audio file's events:
 *
 * le_audio_AddStreamEventHandler() function installs a handler for stream notifications.
 * You can specify the types of events to notify by passing a bit mask as a parameter (cf.
 * @c le_audio_StreamEventBitMask_t).
 *
 * le_audio_RemoveStreamEventHandler() function removes the stream handler function.
 *
 * @warning Only audio file-related events are managed in the current Legato's version.
 *
 * Once the stream event handler is called, the user can call the different functions to retrieve
 * the event's value:
 * - le_audio_GetFileEvent() gets the event's value related to audio file's events.
 *
 * @warning Only audio file-related functions are available in the current Legato's version.
 *
 * The code sample below shows how the User can install a file's event handler.
 * @code
 *
 * // Handler function for Stream Event Notifications.
 * static void MyStreamEventHandler
 * (
 *     le_audio_StreamRef_t          streamRef,
 *     le_audio_StreamEventBitMask_t streamEventMask,
 *     void*                         contextPtr
 * )
 * {
 *     le_audio_FileEvent_t event;
 *
 *     if (streamEventMask & LE_AUDIO_BITMASK_FILE_EVENT)
 *     {
 *         if(le_audio_GetFileEvent(streamRef, &event) == LE_OK)
 *         {
 *             switch(event)
 *             {
 *                 case LE_AUDIO_FILE_ENDED:
 *                     LE_INFO("File event is LE_AUDIO_FILE_ENDED.");
 *                     break;
 *
 *                 case LE_AUDIO_FILE_ERROR:
 *                     LE_INFO("File event is LE_AUDIO_FILE_ERROR.");
 *                     break;
 *             }
 *         }
 *     }
 * }
 *
 *
 * // I must install my audio file event handler as follows:
 * [...]
 *
 * int myAudioFileFd = -1;
 * le_audio_StreamRef_t fileAudioRef = NULL;
 * le_audio_StreamEventHandlerRef_t streamHandlerRef = NULL;
 *
 * myAudioFileFd=open("/myAudioFile.wav", O_RDONLY);
 *
 * fileAudioRef = le_audio_OpenFilePlayback(myAudioFileFd);
 * LE_ERROR_IF((fileAudioRef==NULL), "OpenFilePlayback returns NULL!");
 *
 * streamHandlerRef = le_audio_AddStreamEventHandler(fileAudioRef,
 *                                                   LE_AUDIO_BITMASK_FILE_EVENT,
 *                                                   MyStreamEventHandler,
 *                                                   NULL);
 * LE_ERROR_IF((streamHandlerRef==NULL), "AddFileEventHandler returns NULL!");
 *
 * // Audio playback automatically starts when I connect the fileAudioRef to the connector
 * le_audio_Connect(audioInputConnectorRef, fileAudioRef);
 *
 * [...]
 *
 * @endcode
 *
 *
 * @section le_audio_connectors Create Audio connectors
 *
 * You can create your own audio path by connecting several audio streams together.
 *
 * le_audio_CreateConnector() function creates a reference to an audio connector.
 *
 * You can tie an audio stream to a connector by calling the le_audio_Connect()
 * function.
 *
 * You can remove an audio stream from a connector by calling the le_audio_Disconnect()
 * function.
 *
 * When finished with it, delete it using the le_audio_DeleteConnector() function.
 *
 * @section le_audio_formats Specifying audio formats
 *
 * The encoding audio format can be specified to (or retrieved from) the audio interfaces that
 * support this option. The format parameter is a string containing the IANA specified encoding
 * format name for Real-Time protocol (RTP).
 *
 * The complete list of the audio encoding format names can be found on the IANA organization web
 * site (http://www.iana.org).
 *
 * Function that gets the current audio format for an open interface is:
 * - le_audio_GetFormat()
 *
 * @warning Ensure to check the list of supported audio formats for your specific
 * platform.
 *
 * Some examples of audio formats:
 * - "L16-8K": Linear PCM 16-bit audio @ 8KHz
 * - "L16-16K": Linear PCM 16-bit audio @ 16KHz
 * - "GSM": European GSM Full Rate @ 8KHz (GSM 06.10)
 * - "GSM-EFR": ITU-T GSM Enhanced Full Rate @ 8KHz (GSM 06.60)
 * - "GSM-HR-08": ITU-T GSM Half Rate @ 8KHz (GSM 06.20)
 * - "AMR": Adaptive Multi-Rate - Full Rate @ 8KHz
 * - "AMR-HR": Adaptive Multi-Rate - Half Rate @ 8KHz
 * - "AMR-WB": Adaptive Multi-Rate Wideband @ 16KHz
 *
 * @note The string is not case sensitive.
 *
 * @section le_audio_file_pb_rec Play and record audio
 *
 * An audio file can be played to any active output interfaces.
 *
 * You must open a "File Playback" interface by calling:
 * - le_audio_OpenFilePlayback(): returns an Audio Stream Reference for file playback.
 *                                   The audio file is played on the local audio interface like
 *                                   Speaker, USB Tx, PCM Tx, I2S Tx or on the remote audio
 *                                   interface Modem Voice Tx depending the kind of connector
 *                                   (input or output) is tied to.
 *
 * A "File Playback" interface can be opened only on an active output audio path. For instance, the
 * "I2S Tx" and "Modem Voice Rx" must be previously connected before opening and connecting the
 * "File Playback" interface on the same connector.
 *
 * Audio file recording can be done from any active input interfaces.
 *
 * You must open a "File Recording" interface by calling:
 * - le_audio_OpenFileRecording(): returns an Audio Stream Reference for file recording.
 *                                    The local audio interface like Microphone, USB Rx, PCM Rx,
 *                                    I2S Rx is recorded into an audio file; or the Modem Voice Rx
 *                                    remote audio interface is recorded into an audio file,
 *                                    depending the kind of connector (input or output) is tied to.
 *
 * A "File Recording" interface can be opened only on an active input audio path. For instance, the
 * "I2S Rx" and "Modem Voice Tx" must be previously connected before opening and connecting the
 * "File Recording" interface on the same connector.
 *
 * @note Only .wav file format is currently supported.
 *
 * The function below is an example of how a file can be played to the Modem Voice Tx output
 * interface. The audio of the voice call is redirected to the I2S interfaces. This function simply
 * plays a voice prompt to the remote party when the voice call is established.
 *
 * @code
 *
 * static void ConnectAudioAndPlayVoicePromptToRemoteParty
 * (
 *     void
 * )
 * {
 *     // I get the audio from the voice call.
 *     le_audio_StreamRef_t mdmRxAudioRef = le_audio_OpenModemVoiceRx();
 *     le_audio_StreamRef_t mdmTxAudioRef = le_audio_OpenModemVoiceTx();
 *
 *     // I get the I2S interface references.
 *     le_audio_StreamRef_t i2sTxRef = le_audio_OpenI2sTx(le_audio_GetDefaultI2sMode());
 *     le_audio_StreamRef_t i2sRxRef = le_audio_OpenI2sRx(le_audio_GetDefaultI2sMode());
 *
 *     // I create the audio connectors.
 *     le_audio_ConnectorRef_t audioInputConnectorRef = le_audio_CreateConnector();
 *     le_audio_ConnectorRef_t audioOutputConnectorRef = le_audio_CreateConnector();
 *
 *     // The voice call's audio is redirected to I2S interfaces.
 *     if (mdmRxAudioRef && mdmTxAudioRef && i2sTxRef && i2sRxRef &&
 *         audioInputConnectorRef && audioOutputConnectorRef)
 *     {
 *         le_audio_Connect(audioInputConnectorRef, i2sRxRef);
 *         le_audio_Connect(audioInputConnectorRef, mdmTxAudioRef);
 *         le_audio_Connect(audioOutputConnectorRef, i2sTxRef);
 *         le_audio_Connect(audioOutputConnectorRef, mdmRxAudioRef);
 *     }
 *
 *     // I get the interface reference for file playback.
 *     int fd = open("/myvoiceprompt.wav", O_RDONLY));
 *     le_audio_StreamRef_t fileAudioRef = le_audio_OpenFilePlayback(fd);
 *
 *     // The audio file is played on the input connector, the remote party can now hear the voice
 *     // prompt.
 *     if (fileAudioRef && audioInputConnectorRef)
 *     {
 *         le_audio_Connect(audioInputConnectorRef, fileAudioRef);
 *     }
 * }
 *
 * @endcode
 *
 * @section le_audio_dtmf DTMF
 *
 * @todo DTMF encoding will be available in a future release.
 *
 * The application must register a handler function to detect incoming DTMF characters on a specific
 * input audio stream. The le_audio_AddDtmfDetectorHandler() function installs a handler for DTMF
 * detection.
 *
 * The le_audio_RemoveDtmfDetectorHandler() function uninstalls the handler function.
 *
 * The DTMFs are: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, *, #, A, B, C, D. Not case sensitive.
 *
 * @note The DTMF decoding works only on an active audio path.
 *
 * @section le_audio_samples Code samples
 *
 * The following two code samples show how to create different audio paths for an
 * incoming voice call.
 *
 * The first example has the audio path depending on an USB Audio handset. The
 * @b ConnectVoiceCallAudio() function creates this audio path. A USB Audio handset
 * plugged in and fully operationnal, will redirect the call audio to the handset; otherwise, it will
 * redirect the call to the default microphone and speaker.
 *
 * Use DisconnectVoiceCallAudio() to delete the audio path.
 *
 * @code
 *
 * le_result_t ConnectVoiceCallAudio
 * (
 *     le_audio_ConnectorRef_t*  audioInputConnectorRefPtr,  // [OUT] Input connector.
 *     le_audio_ConnectorRef_t*  audioOutputConnectorRefPtr, // [OUT] Output connector.
 *     le_audio_StreamRef_t*     mdmRxAudioRefPtr,           // [OUT] Received voice call audio stream.
 *     le_audio_StreamRef_t*     mdmTxAudioRefPtr,           // [OUT] Transmitted voice call audio stream.
 *     le_audio_StreamRef_t*     deviceRxAudioRefPtr,        // [OUT] Received device audio stream.
 *     le_audio_StreamRef_t*     deviceTxAudioRefPtr         // [OUT] Transmitted device audio stream.
 * )
 * {
 *     // I get the audio from the voice call.
 *     *mdmRxAudioRefPtr = le_audio_OpenModemVoiceRx();
 *     *mdmTxAudioRefPtr = le_audio_OpenModemVoiceTx();
 *
 *     // If I cannot get the audio from the voice call, I return an error.
 *     if ((*mdmRxAudioRefPtr == NULL) || (*mdmTxAudioRefPtr == NULL))
 *     {
 *             // I close the audio interfaces that have failed to open.
 *             le_audio_Close(*mdmRxAudioRefPtr);
 *             le_audio_Close(*mdmTxAudioRefPtr);
 *             return LE_FAULT;
 *     }
 *
 *     // I create the audio connectors.
 *     *audioInputConnectorRefPtr = le_audio_CreateConnector();
 *     *audioOutputConnectorRefPtr = le_audio_CreateConnector();
 *
 *     // I verify if my Audio USB handset is plugged and operational before trying to use it.
 *     if(IsMyUSBHandsetPlugged() == TRUE)
 *     {
 *         // I can redirect the audio to my USB handset using linear PCM audio format (PCM 16bits @ 16KHz)
 *         *deviceRxAudioRefPtr = le_audio_OpenUsbRx();
 *         *deviceTxAudioRefPtr = le_audio_OpenUsbTx();
 *
 *         le_audio_Connect(*audioInputConnectorRefPtr, *deviceRxAudioRefPtr);
 *         le_audio_Connect(*audioOutputConnectorRefPtr, *deviceTxAudioRefPtr);
 *     }
 *     else
 *     {
 *         // There is no USB Audio handset, I redirect the audio to the in-built Microphone and Speaker.
 *         *deviceRxAudioRefPtr = le_audio_OpenMic();
 *         *deviceTxAudioRefPtr = le_audio_OpenSpeaker();
 *
 *         le_audio_Connect(*audioInputConnectorRefPtr, *deviceRxAudioRefPtr);
 *         le_audio_Connect(*audioOutputConnectorRefPtr, *deviceTxAudioRefPtr);
 *     }
 *
 *     // I tie the audio from the voice call to the connectors.
 *     le_audio_Connect (*audioInputConnectorRefPtr, *mdmTxAudioRefPtr);
 *     le_audio_Connect (*audioOutputConnectorRefPtr, *mdmRxAudioRefPtr);
 *
 *     return LE_OK;
 * }
 *
 *
 * void DisconnectVoiceCallAudio
 * (
 *     le_audio_ConnectorRef_t  audioInputConnectorRef,  // [IN] Input connector.
 *     le_audio_ConnectorRef_t  audioOutputConnectorRef, // [IN] Output connector.
 *     le_audio_StreamRef_t     mdmRxAudioRef,           // [IN] Received voice call audio stream.
 *     le_audio_StreamRef_t     mdmTxAudioRef,           // [IN] Transmitted voice call audio stream.
 *     le_audio_StreamRef_t     deviceRxAudioRef,        // [IN] Received device audio stream.
 *     le_audio_StreamRef_t     deviceTxAudioRef         // [IN] Transmitted device audio stream.
 * )
 * {
 *     // The call is terminated, I can close its audio interfaces.
 *     le_audio_Close(mdmRxAudioRef);
 *     le_audio_Close(mdmTxAudioRef);
 *
 *     // I close all the device interfaces.
 *     le_audio_Close(deviceRxAudioRef);
 *     le_audio_Close(deviceTxAudioRef);
 *
 *     // I delete the Audio connector references.
 *     le_audio_DeleteConnector(audioInputConnectorRef);
 *     le_audio_DeleteConnector(audioOutputConnectorRef);
 * }
 *
 * @endcode
 *
 * The next code sample uses specific functions to deal with a new 'Incoming call' event during a call
 * already in progress.
 *
 * If no call is in progress,  use the ConnectVoiceCallAudio() function to redirect the
 * call audio to the in-built Microphone and Speaker.
 *
 * If a new call is incoming, and considered a high priority call, you must mute the audio
 * of the first call, and then connect the new call to your current audio path.
 * Use SwitchVoiceCallAudio() for these actions.
 *
 * When the high priority call terminates, you can return back to your previous call and reactivate its
 * audio with the SwitchBackVoiceCallAudio() function.
 *
 * @code
 *
 * le_result_t ConnectVoiceCallAudio
 * (
 *     le_audio_ConnectorRef_t*  audioInputConnectorRefPtr,  // [OUT] Input connector.
 *     le_audio_ConnectorRef_t*  audioOutputConnectorRefPtr, // [OUT] Output connector.
 *     le_audio_StreamRef_t*     mdmRxAudioRefPtr,           // [OUT] Received voice call audio stream.
 *     le_audio_StreamRef_t*     mdmTxAudioRefPtr,           // [OUT] Transmitted voice call audio stream.
 *     le_audio_StreamRef_t*     micRefPtr,                  // [OUT] Microphone stream.
 *     le_audio_StreamRef_t*     speakerRefPtr               // [OUT] Speaker stream.
 * )
 * {
 *     *mdmRxAudioRefPtr = le_audio_OpenModemVoiceRx();
 *     *mdmTxAudioRefPtr = le_audio_OpenModemVoiceTx();
 *
 *     // If I cannot get the audio from the voice call, I return an error.
 *     if ((*mdmRxAudioRefPtr == NULL) || (*mdmTxAudioRefPtr == NULL))
 *     {
 *             // I close the audio interfaces that  have failed to open.
 *             le_audio_Close(*mdmRxAudioRefPtr);
 *             le_audio_Close(*mdmTxAudioRefPtr);
 *             return LE_FAULT;
 *     }
 *
 *     *audioInputConnectorRefPtr = le_audio_CreateConnector();
 *     *audioOutputConnectorRefPtr = le_audio_CreateConnector();
 *
 *     // Redirect audio to the in-built Microphone and Speaker.
 *     *speakerRefPtr = le_audio_OpenSpeaker();
 *     *micRefPtr = le_audio_OpenMic();
 *
 *     le_audio_Connect(*audioInputConnectorRefPtr, *micRefPtr);
 *     le_audio_Connect (*audioInputConnectorRefPtr, *mdmTxAudioRefPtr);
 *     le_audio_Connect(*audioOutputConnectorRefPtr, *speakerRefPtr);
 *     le_audio_Connect (*audioOutputConnectorRefPtr, *mdmRxAudioRefPtr);
 *
 *     return LE_OK;
 * }
 *
 *
 * le_result_t SwitchVoiceCallAudio
 * (
 *     le_audio_ConnectorRef_t  audioInputConnectorRef,  // [IN] Input connector.
 *     le_audio_ConnectorRef_t  audioOutputConnectorRef, // [IN] Output connector.
 *     le_audio_StreamRef_t     oldMdmRxAudioRef,        // [IN] Received audio stream of the previous voice call.
 *     le_audio_StreamRef_t     oldMdmTxAudioRef,        // [IN] Transmitted audio stream of the previous voice call.
 *     le_audio_StreamRef_t*    newMdmRxAudioRefPtr,     // [OUT] Received audio stream of the new voice call.
 *     le_audio_StreamRef_t*    newMdmTxAudioRefPtr      // [OUT] Transmitted audio stream of the new voice call.
 * )
 * {
 *     if ((newMdmRxAudioRefPtr == NULL)     ||
 *         (newMdmTxAudioRefPtr == NULL))
 *     {
 *         return LE_BAD_PARAMETER;
 *     }
 *
 *     *newMdmRxAudioRefPtr = le_audio_OpenModemVoiceRx();
 *     *newMdmTxAudioRefPtr = le_audio_OpenModemVoiceTx();
 *
 *     // If I cannot get the audio from the voice call, I return an error.
 *     if ((*newMdmRxAudioRefPtr == NULL) || (*newMdmTxAudioRefPtr == NULL))
 *     {
 *         // I close the audio interfaces that have failed to open.
 *         le_audio_Close(*newMdmRxAudioRefPtr);
 *         le_audio_Close(*newMdmTxAudioRefPtr);
 *         return LE_FAULT;
 *     }
 *
 *     // I mute the previous call.
 *     le_audio_Mute(oldMdmRxAudioRef);
 *     le_audio_Mute(oldMdmTxAudioRef);
 *
 *     // I connect the new incoming call.
 *     le_audio_Connect (audioInputConnectorRef, *newMdmTxAudioRefPtr);
 *     le_audio_Connect (audioOutputConnectorRef, *newMdmRxAudioRefPtr);
 *
 *     return LE_OK;
 * }
 *
 *
 * le_result_t SwitchBackVoiceCallAudio
 * (
 *     le_audio_StreamRef_t  oldMdmRxAudioRef, // [IN] Received audio stream of the previous voice call.
 *     le_audio_StreamRef_t  oldMdmTxAudioRef, // [IN] Transmitted audio stream of the previous voice call.
 *     le_audio_StreamRef_t  newMdmRxAudioRef, // [IN] Received audio stream of the new voice call.
 *     le_audio_StreamRef_t  newMdmTxAudioRef  // [IN] Transmitted audio stream  of the new voice call.
 * )
 * {
 *     // I can delete the new call audio interfaces.
 *     le_audio_Close(newMdmRxAudioRef);
 *     le_audio_Close(newMdmTxAudioRef);
 *
 *     // I can re-open the previous call streaming.
 *     if (le_audio_Unmute(oldMdmRxAudioRef) != LE_OK)
 *     {
 *         return LE_FAULT;
 *     }
 *     if (le_audio_Unmute(oldMdmTxAudioRef) != LE_OK)
 *     {
 *         return LE_FAULT;
 *     }
 *
 *     return LE_OK;
 * }
 *
 * @endcode
 *
 * <HR>
 *
 * Copyright (C) Sierra Wireless Inc. Use of this work is subject to license.
 */


/** @file le_audio_interface.h
 *
 * Legato @ref c_audio include file.
 *
 * Copyright (C) Sierra Wireless Inc. Use of this work is subject to license.
 */

//--------------------------------------------------------------------------------------------------
/**
 * Stream Events Bit Mask
 */
//--------------------------------------------------------------------------------------------------
BITMASK StreamEventBitMask
{
    BITMASK_FILE_EVENT,    ///< event related to audio file's event
};

//--------------------------------------------------------------------------------------------------
/**
 * Audio file recording/playback events.
 */
//--------------------------------------------------------------------------------------------------
ENUM FileEvent
{
    FILE_ENDED,         ///< File playback has reached the end of file.
    FILE_ERROR          ///< File recording/playback has encountered an error.
};

//--------------------------------------------------------------------------------------------------
/**
 * Audio profiles.
 */
//--------------------------------------------------------------------------------------------------
ENUM Profile
{
    HANDSFREE,          ///< Handsfree profile.
    HANDSET,            ///< Handset profile.
    HEADSET,            ///< Headset profile.
    TTY,     ///< Teletypewriter profile (for hearing impaired use cases).
    USB                 ///< USB profile.
};

//--------------------------------------------------------------------------------------------------
/**
 * Companding.
 */
//--------------------------------------------------------------------------------------------------
ENUM Companding
{
    COMPANDING_ALAW,  ///< A-law PCM (i.e. Europe and most of the rest of the world).
    COMPANDING_ULAW,  ///< MU-law PCM (i.e. North America and Japan).
    COMPANDING_NONE   ///< Linear PCM.
};

//--------------------------------------------------------------------------------------------------
/**
 * I2S channel mode.
 */
//--------------------------------------------------------------------------------------------------
ENUM I2SChannel
{
    I2S_LEFT,     ///< Left channel.
    I2S_RIGHT,    ///< Right channel.
    I2S_MONO,     ///< Mono mode.
    I2S_STEREO,   ///< Stereo mode.
    I2S_REVERSE   ///< Reverse mode (left & right reversed).
};

//--------------------------------------------------------------------------------------------------
/**
 * Maximum DTMF string length.
 */
//--------------------------------------------------------------------------------------------------
DEFINE DTMF_MAX_LEN   = (100);
DEFINE DTMF_MAX_BYTES = (DTMF_MAX_LEN+1);

//--------------------------------------------------------------------------------------------------
/**
 * Reference type for Audio Stream
 */
//--------------------------------------------------------------------------------------------------
REFERENCE Stream;


//--------------------------------------------------------------------------------------------------
/**
 * Reference type for Audio Connector
 */
//--------------------------------------------------------------------------------------------------
REFERENCE Connector;


//--------------------------------------------------------------------------------------------------
/**
 * Open the Microphone.
 *
 * @return Reference to the input audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenMic
(
);

//--------------------------------------------------------------------------------------------------
/**
 * Open the Speakerphone.
 *
 * @return Reference to the output audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenSpeaker
(
);

//--------------------------------------------------------------------------------------------------
/**
 * Open the received audio stream of an USB audio class.
 *
 * @return Reference to the input audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenUsbRx
(
);

//--------------------------------------------------------------------------------------------------
/**
 * Open the transmitted audio stream of an USB audio class.
 *
 * @return Reference to the output audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenUsbTx
(
);

//--------------------------------------------------------------------------------------------------
/**
 * Open the received audio stream of the PCM interface.
 *
 * @return Reference to the input audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenPcmRx
(
    uint32 timeslot  IN ///< The time slot number.
);

//--------------------------------------------------------------------------------------------------
/**
 * Open the transmitted audio stream of the PCM interface.
 *
 * @return Reference to the output audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenPcmTx
(
    uint32 timeslot  IN ///< The time slot number.
);

//--------------------------------------------------------------------------------------------------
/**
 * Open the received audio stream of the I2S interface.
 *
 * @return Reference to the input audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenI2sRx
(
    I2SChannel mode  IN ///< The channel mode.
);

//--------------------------------------------------------------------------------------------------
/**
 * Open the transmitted audio stream of the I2S interface.
 *
 * @return Reference to the output audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenI2sTx
(
    I2SChannel mode  IN ///< The channel mode.
);

//--------------------------------------------------------------------------------------------------
/**
 * Open the audio stream for file playback.
 *
 * @return Reference to the audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenFilePlayback
(
    file fd      IN ///< The file descriptor.
);

//--------------------------------------------------------------------------------------------------
/**
 * Open the audio stream for file recording.
 *
 * @return Reference to the audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenFileRecording
(
    file fd      IN ///< The file descriptor.
);

//--------------------------------------------------------------------------------------------------
/**
 * Open the received audio stream of a voice call.
 *
 * @return Reference to the input audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenModemVoiceRx
(
);

//--------------------------------------------------------------------------------------------------
/**
 * Open the transmitted audio stream of a voice call.
 *
 * @return Reference to the output audio stream, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Stream OpenModemVoiceTx
(
);

//--------------------------------------------------------------------------------------------------
/**
 * Handler for audio stream event.
 *
 */
//--------------------------------------------------------------------------------------------------
HANDLER StreamEventHandler
(
    Stream               streamRef  IN,       ///< The audio stream reference.
    StreamEventBitMask   streamEventMask IN   ///< The type of stream events.
);

//--------------------------------------------------------------------------------------------------
/**
 * This event provides information on audio stream events for the specified streamRef
 *
 */
//--------------------------------------------------------------------------------------------------
EVENT StreamEvent
(
    Stream               streamRef IN,        ///< The audio stream reference.
    StreamEventBitMask   streamEventMask IN,  ///< The type of stream events to be notified.
    handler StreamEventHandler
);

//--------------------------------------------------------------------------------------------------
/**
 * Retrieve the file-related event value.
 *
 * @return
 *      - LE_OK The function succeeded.
 *      - LE_NOT_FOUND The event is not related to a file event
 *      - LE_FAULT The function failed
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t GetFileEvent
(
    Stream    streamRef IN,  ///< The audio stream reference.
    FileEvent event     OUT  ///< The Audio file recording/playback events.
);

//--------------------------------------------------------------------------------------------------
/**
 * Get the audio format of an input or output stream.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OVERFLOW      The format buffer wasn't big enough to accept the audio format string
 * @return LE_OK            The function succeeded.
 *
 * @note The process exits, if an invalid audio stream reference is given or if the formatPtr
 *       pointer is NULL.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t GetFormat
(
    Stream streamRef IN,        ///< The audio stream reference.
    string formatPtr[30] OUT    ///< The name of the audio encoding as used by the Real-Time
                                ///< Protocol (RTP), specified by the IANA organisation.
);

//--------------------------------------------------------------------------------------------------
/**
 * Close an audio stream.
 * If several users own the stream reference, the interface closes only after
 * the last user closes the audio stream.
 *
 * @note If the caller is passing a bad reference into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Close
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * Set the Gain value of an input or output stream.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_BAD_PARAMETER Audio stream reference is invalid.
 * @return LE_OUT_OF_RANGE  Gain parameter is not between 0 and 100
 * @return LE_OK            Function succeeded.
 *
 * @note The hardware may or may not support the full 0-100 resolution, and if you want to see what
 * was actually set call le_audio_GetGain() after le_audio_SetGain() to get the real value.
 *
 * @note If the caller is passing a bad reference into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t SetGain
(
    Stream streamRef IN,    ///< Audio stream reference.
    uint32 gain IN          ///< Gain value [0..100]
                            ///< (0 means 'muted', 100 is the maximum gain value)
);

//--------------------------------------------------------------------------------------------------
/**
 * Get the Gain value of an input or output stream.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_BAD_PARAMETER Audio stream reference is invalid.
 * @return LE_OK            Function succeeded.
 *
 * @note The hardware may or may not support the full 0-100 resolution, and if you want to see what
 * was actually set call le_audio_GetGain() after le_audio_SetGain() to get the real value.
 *
 * @note If the caller is passing a bad reference into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t GetGain
(
    Stream streamRef IN,    ///< Audio stream reference.
    uint32 gain OUT         ///< Gain value [0..100]
                            ///< (0 means 'muted', 100 is the maximum gain value)
);

//--------------------------------------------------------------------------------------------------
/**
 * Mute an audio stream.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_BAD_PARAMETER Audio stream reference is invalid.
 * @return LE_OK            Function succeeded.
 *
 * @note If the caller is passing a bad reference into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t Mute
(
    Stream streamRef IN ///< The audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * Unmute an audio stream.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_BAD_PARAMETER Audio stream reference is invalid.
 * @return LE_OK            Function succeeded.
 *
 * @note If the caller is passing a bad reference into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t Unmute
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * Create an audio connector reference.
 *
 * @return Reference to the audio connector, NULL if the function fails.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Connector CreateConnector
(
);

//--------------------------------------------------------------------------------------------------
/**
 * Delete an audio connector reference.
 *
 * @note If the caller is passing a bad reference into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION DeleteConnector
(
    Connector connectorRef IN ///< Connector reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * Connect an audio stream to the connector reference.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_BUSY          Insufficient DSP resources available.
 * @return LE_BAD_PARAMETER Connector and/or the audio stream references are invalid.
 * @return LE_OK            Function succeeded.
 *
 * @note If the caller is passing a bad reference into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t Connect
(
    Connector connectorRef IN,  ///< Connector reference.
    Stream    streamRef IN      ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * Disconnect an audio stream from the connector reference.
 *
 * @note If the caller is passing a bad reference into this function, it is a fatal error, the
 *       function will not return.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Disconnect
(
    Connector connectorRef IN,  ///< Connector reference.
    Stream    streamRef IN      ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * Handler for DTMF decoding.
 *
 */
//--------------------------------------------------------------------------------------------------
HANDLER DtmfDetectorHandler
(
    Stream      streamRef  IN,    ///< The audio stream reference.
    char        dtmf       IN     ///< Detected DTMF.
);

//--------------------------------------------------------------------------------------------------
/**
 * This event provides information on DTMF decoding for the specified streamRef
 *
 */
//--------------------------------------------------------------------------------------------------
EVENT DtmfDetector
(
    Stream      streamRef IN,     ///< The audio stream reference.
    handler DtmfDetectorHandler
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to enable the Noise Suppressor.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 * @note The process exits, if an invalid audio stream reference is given.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t EnableNoiseSuppressor
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to disable the Noise Suppressor.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 * @note The process exits, if an invalid audio stream reference is given.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t DisableNoiseSuppressor
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to enable the Echo Canceller.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 * @note The process exits, if an invalid audio stream reference is given.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t EnableEchoCanceller
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to disable the Echo Canceller.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 * @note The process exits, if an invalid audio stream reference is given.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t DisableEchoCanceller
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to enable the FIR (Finite Impulse Response) filter.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 * @note The process exits, if an invalid audio stream reference is given.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t EnableFirFilter
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to disable the FIR (Finite Impulse Response) filter.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 * @note The process exits, if an invalid audio stream reference is given.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t DisableFirFilter
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to enable the IIR (Infinite Impulse Response) filter.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 * @note The process exits, if an invalid audio stream reference is given.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t EnableIirFilter
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to disable the IIR (Infinite Impulse Response) filter.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 * @note The process exits, if an invalid audio stream reference is given.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t DisableIirFilter
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to enable the automatic gain control on the selected audio stream.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 * @note The process exits, if an invalid audio stream reference is given.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t EnableAutomaticGainControl
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to disable the automatic gain control on the selected audio stream.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 * @note The process exits, if an invalid audio stream reference is given.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t DisableAutomaticGainControl
(
    Stream streamRef IN ///< Audio stream reference.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to set the audio profile.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t SetProfile
(
    le_audio_Profile_t profile  IN ///< The audio profile.
);

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to get the audio profile in use.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OK            Function succeeded.
 *
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t GetProfile
(
    le_audio_Profile_t profile  OUT ///< The audio profile.
);


//--------------------------------------------------------------------------------------------------
/**
 * Configure the PCM Sampling Rate.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OUT_OF_RANGE  Your platform does not support the setting's value.
 * @return LE_BUSY          The PCM interface is already active.
 * @return LE_OK            Function succeeded.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t SetPcmSamplingRate
(
    uint32      rate   IN  ///< Sampling rate in Hz.
);

//--------------------------------------------------------------------------------------------------
/**
 * Configure the PCM Sampling Resolution.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OUT_OF_RANGE  Your platform does not support the setting's value.
 * @return LE_BUSY          The PCM interface is already active.
 * @return LE_OK            Function succeeded.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t SetPcmSamplingResolution
(
    uint32      bitsPerSample   IN  ///< Sampling resolution (bits/sample).
);

//--------------------------------------------------------------------------------------------------
/**
 * Configure the PCM Companding.
 *
 * @return LE_FAULT         Function failed.
 * @return LE_OUT_OF_RANGE  Your platform does not support the setting's value.
 * @return LE_BUSY          The PCM interface is already active.
 * @return LE_OK            Function succeeded.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION le_result_t SetPcmCompanding
(
    Companding  companding      IN  ///< Companding.
);

//--------------------------------------------------------------------------------------------------
/**
 * Retrieve the PCM Sampling Rate.
 *
 * @return The sampling rate in Hz.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION uint32 GetPcmSamplingRate
(
);

//--------------------------------------------------------------------------------------------------
/**
 * Retrieve the PCM Sampling Resolution.
 *
 * @return The sampling resolution (bits/sample).
 */
//--------------------------------------------------------------------------------------------------
FUNCTION uint32 GetPcmSamplingResolution
(
);

//--------------------------------------------------------------------------------------------------
/**
 * Retrieve the PCM Companding.
 *
 * @return The PCM companding.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION Companding GetPcmCompanding
(
);

//--------------------------------------------------------------------------------------------------
/**
 * Get the default PCM time slot used on the current platform.
 *
 * @return the time slot number.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION uint32 GetDefaultPcmTimeSlot
(
);

//--------------------------------------------------------------------------------------------------
/**
 * Get the default I2S channel mode used on the current platform.
 *
 * @return the I2S channel mode.
 */
//--------------------------------------------------------------------------------------------------
FUNCTION I2SChannel GetDefaultI2sMode
(
);
