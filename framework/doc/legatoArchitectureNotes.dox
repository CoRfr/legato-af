/** @page legatoArchitecture Legato Architecture Notes


@ref legatoComponents  <br>
@ref archnotesLegatoServices  <br>
@ref legatoApplications  <br>
@ref legatoDeployments  <br>


@section legatoComponents Components and Interfaces

A Legato component can be almost anything. The only requirement is that it must contain something runnable:  
 - imported interfaces and data streams.
 - exported interfaces and data streams.
 - executables.
 - shared libraries.
 - data or configuration files.

@image html GenericComponent.png

You need at least one executable or one shared library to link to a client.  The choice is up to the
component; the component's client is unaware of how it is linked.  Component clients 
only connect to a component's interface, not its implemtation.


@subsection legatoComponentsDirect Direct Communication

Components can directly communicate through simple function calls when 
implemented as a shared library.

This is most straight forward in C. An interface defines various objects, methods, and
function calls.  This gets turned into C functions and structures.  The client code then
calls these functions directly.

If a component is written in another language, then a marshalling layer is automatically
generated at compile time that takes care of cross component calls.

@subsection legatoComponentsIPC Client/Server IPC

When a component is implemented as an executable, IPC is required.  Just like direct
communication, the interface is automatically generated.  The surface API 
looks identical, but the underlying implentation is an inter-process
protocol. The server is then the component providing the interface, and the client is
the component consuming the interface.

Similar to when languages other than C are used, a marshalling layer is generated 
now using the IPC protocol.

@subsection legatoComponentsDataStreams Data Streams

Data streams provide a data source (e.g., sensor readings), and they also hide the implentation details.

This way, a specified component can obtain the current position of a device, but
doesn't need to how that position was obtained.  In fact, the component may not be obtaining 
a direct position reading; it may be aggregating readings from
multiple sources using an accuracy filter.

@subsection legatoComponentsPackaging Component Packaging

Components are built into a single package for sharing and deployment.  A component definition file
is required for the build system so it knows which package to use.  The component
packager generates a component file that's digitally signed, and contains all 
files and meta-data to be installed on a target device.

@subsection Geo-fence Geo-fence component definition 

For a component profile using a geo-fencing interface, the component needs to
know the device's current position, and provide call backs when the device enters and
exits its defined area. The interface provided by libMyGeoFence.so depends on
a math library and a data file to define the "valid" area.

Code sample for the component definition file:

@verbatim

component MyGeoFence
{
    // These are the interfaces the compoent imports and exports.  In this case, no interfaces are
    // imported, one interface is exported.
    interface
    {
        import { }

        export
        {
            "Geo-Fence" location.GeoFence
        }
    }

    // The component needs to bind to the position data stream; it
    // doesn't export any data streams of its own.
    data
    {
        in
        {
            Position
                @legato location.Position
                        #8afb4be71f11b1945a55f61ad8522868

            Time
                @legato time.WallClock
                        #c3e5bb39008f69628e2dfb44b2a874c7
        }

        out { }
    }

    // The system needs to know the interfaces are provided by and imported by this executable.
    exec MyGeoFenceExec

    // These are the extra files that the component requires to function.
    files
    {
        libGeoMath.so
        LocationGeometry.dat
    }
}

@endverbatim

@section archnotesLegatoServices Legato Services

Every application and component developer gets an account on the component catalog website 
where they can then publish their components and interfaces. This can be set up as public or private.

If an interface/component/application is private, you can share
that component with a defined list of other developers or orginizations.

@ref legatoServices 

@section legatoApplications Legato Applications

An application is a collection of components with a description of how those components are
bound together.  When you develop a component, you build that component to work with
interfaces, not impentations. When you build an application, you provide interfaces required to run the component.
It's essentially how the applications are connected. Components can be connected to an application's external interface.  
It's how applications communicate with each other accross sandboxes.

Every application gets a sandbox.  Components reside within their application's sandbox. 
Every sandbox has a set of permissions associated with it.
If an application tries to exceed these permissions, it will fail. Because an application
is a collection of components, the permissions required are the sum of all of the
permissions required by the components comprising that application.

@subsection Geo-fenceApp Geo-fence application sample code 

This code sample uses a geo-fencing application to get a position from an attached GPS
device and a cell modem. The application then provides a GeoFence interface that can be bound
into another app like this:

@verbatim

application MyPositionTrackingApp
{
    // The system needs to know which component to start first.
    main Fence

    // List our components and give them names for later referal.
    components
    {
        Fence location.MyGeoFence #d2a08ff7888a06d5e6a158d8d1c87a09

        Gps @legato location.GpsLocation #6d557a1c325ace0070dfa4f42ff6092b
        Net @legato location.NetLocation #7c3b648c4cb58c86742019b220913e99

        Aggregator @legato location.LocationAggregator #c9225c7b981a1fecfd1be88241718fb1
    }

    // Now bind our component interfaces to each other.
    bindings
    {
        Gps.Position -> Aggregator.InputPosition1
        Net.Position -> Aggregator.InputPosition2

        Aggrigator.OutputPosition -> Fence.Position
    }

    // The interfaces we can't satisfy internally are bound to the application's external
    // interface.
    external
    {
        "Serial I/O"   as Gps.Connection
        "Data Service" as Net.Modem
        GeoFence       as Fence.GeoFence
    }
}

@endverbatim

@section legatoDeployments Deploying Legato Applications

Once applications are built, they can be then deployed to devices; Legato uses 
deployment packages that can include one or more applications.

The deployment packages connect an application's external interface to interfaces provided by
the device.  Applications can also be connected to each other.  This way, the device's applications 
can also provide useful services that can be consumed by other
applications.

@subsection Geo-fenceDeploy Geo-fence deployment sample 

To deploy the geo-fencing sample application, write a deployment definition that
includes a location alert application and a connection to our geo-fencing app like this:

@verbatim

deployment "Geo Notification Device"
{
    device SierraWireless.Ar7

    applications
    {
        GeoFencer MyPositionTrackingApp #e123f3cb569af675bd5d3eaf660a47c6
        PositionAlert MyAlertApp #3dce4734080c9a1fe3262f5b46a90915
    }

    bindings
    {
        "DEVICE.GPS Connection" -> "GeoFencer.Serial I/O"

        "DEVICE.Modem - SIM 1" -> "GeoFencer.Data Service"
        "DEVICE.Modem - SIM 1" -> PositionAlert.Data


        GeoFencer.GeoFence -> PositionAlert.GeoFence
    }
}

@endverbatim

Legat also supports nested deployments.  One user, "User A," builds an
application and a deployment for a specified device.  That user then exports interfaces to the
deployment's external interface.

"User A," can then give this deployment to, "User B," to extend it.  "User B," then adds their
application and connects to the interfaces "User A," exposed. This way "User A"
can control the resources of devices that "User B" accesses.

A deployment definition can then be packaged and installed on a
device.  This package will include every file and definition for all compnents the
applications require.

A car manufacturer could work with car rental company to export services to the car rental fleet from that manufacturer. 

Here's a what a car manufacturer and rental company deployment might look like:

@image html DeploymentSample.png

The rental company's application consumes services from both car manufacturer and the device itself. 

Here's a code sample of a car manufacturer and rental company composit deployment:

@verbatim

deployment "Auto Base Deployment"
{
    device SierraWireless.Ar7
           #218e81a6dcf412219a2428c4557dd638

    applications
    {
        Auto @automfg public.AutoInterfaceApp #80718c9d90183c0c18d3e12a098b965d
    }

    bindings
    {
        "DEVICE.Modem - SIM 1" -> "Auto.Customer Modem"
        "DEVICE.Modem - SIM 2" -> "Auto.Manufacturer Modem"
    }

    external
    {
        "Engine Condition" as Auto.EngineCondition
        Mileage as Auto.Mileage

        Modem as "DEVICE.Modem - SIM 1"
    }
}

@endverbatim

@verbatim

deployment "RentCo Deployment"
{
    extends "AutoMfg Base Deployment" #8f181a974c1f85050778616ec3f81064

    applications
    {
        RentCo @autorent rentalService.RentCoApp #1a7bd96eb009876adcfd869b8bf6ed66
    }

    bindings
    {
        DEVICE.Modem -> RentCo.Modem

        "DEVICE.Engine Condition" -> "RentCo.Engine Condition"
        DEVICE.Mileage -> RentCo.Mileage
    }
}

@endverbatim



<HR>

Copyright (C) Sierra Wireless, Inc. 2014. All rights reserved.

**/
