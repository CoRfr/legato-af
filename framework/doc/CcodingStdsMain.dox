/** @page CcodingStdsMain C Language Coding Standards


@ref cstdsCyclomatic  <br>
@ref cstdsFanOut  <br>
@ref cstdsRecursion  <br>
@ref cstdsGotos  <br>
@ref cstdsGlobalVariables  <br>
@ref cstdsExtern  <br>
@ref cstdsHeap  <br>
@ref cstdsMultipleInclusionGuards  <br>
@ref cstdsLineLength  <br>
@ref cstdsExistingCode  <br>
@ref cstdsNaming  <br>
@ref cstdsPrefixesOverview  <br>
@ref cstdsInterComponentInterfaces  <br>
@ref cstdsInterModuleInterfaces  <br>
@ref cstdsFiles  <br>
@ref cstdsMacros  <br>
@ref cstdsNameSuffix  <br>
@ref cstdsNamePrefix  <br>
@ref cstdsNameType  <br>
@ref cstdsCardinalTypes  <br>
@ref cstdsEnumerationMembers  <br>
@ref cstdsStructandUnionNamespaces  <br>
@ref cstdsStructandUnionMembers  <br>
@ref cstdsPrefix  <br>
@ref cstdsCamelCaseName  <br>
@ref cstdsVerbage  <br>

Other C standards pages: 

@subpage CStandardsAbbreviations  <br>
@subpage CStandardsParameters

@section cstdsCyclomatic Cyclomatic Complexity

http://en.wikipedia.org/wiki/Cyclomatic_complexity/Cyclomatic complexity is a measurement of the complexity of code within a function.  
It's measured by counting branches within a function.

Each function gets a starting value of 1, and 1 is added for every "if" (or "?"), every loop (for, do, or while), and every "case".

For example, the following code has a cyclomatic complexity of 3:

@code
int main(int argc, char** argv)
{
    int i;
    int result = 0;

    if (argc <= 0)
    {
        printf("No arguments provided.\n");
        result = 1;
    }
    else
    {
        printf("argc = %d\n", argc);

        for (i = 0; i < argc; i++)
        {
            printf("argv[%d] = '%s'\n", argv[i]);
        }
    }
    return result;
}


@endcode

Higher levels of cyclomatic complexity are correlated with higher defect density.

All functions should have a cyclomatic complexity of 10 or less.

All functions must have a cyclomatic complexity of less than 15.

@section cstdsFanOut Fan Out

Fan-out is a measurement of the number of different functions that are called by a given function, plus the number of data structures that it updates.  
High  levels of fan-out are indicative of insufficient abstraction and are correlated with higher defect density.

For example, the following function has a fan-out of 5:
@code
static int Log(int value)
{
    if (IsAboveThreshold(value))
    {
        LogEntry_t* entryPtr = AllocEntry();
        if (entryPtr == NULL)
        {
            ReportError("Out of memory!");
        }
        else
        {
            entryPtr->value = value;
            entryPtr->timestamp = GetTimestamp();

            // Add the entry to the log entry list.
            LogEntryList[NextEntryIndex++] = entryPtr;
            if (NextExtryIndex >= LOG_SIZE)
            {
                NextEntryIndex = 0; // wrap around
            }
            if (NextEntryIndex == LastEntryIndex)
            {
                ReportError("Log overflow! Log entry discarded.");
                LastEntryIndex = (LastEntryIndex + 1) % LOG_SIZE;
            }
        }
    }
}

@endcode

The functions IsAboveThreshold(), AllocEntry(), ReportError(), and GetTimestamp() are called by the Log() function.  
In addition, the "Log" data structure (consisting of the variables LogEntryList, NextEntryIndex, and LastEntryIndex) is updated by the Log() function.  
Note that the second and subsequent calls to the same function are not counted. So, even though ReportError() is called twice by Log(), it only 
contributes 1 to the fan-out.

Ideally, fan-out should be kept to 7 or less.

Fan-out must be kept to 10 or less.

@section cstdsRecursion Recursion

Recursion can be dangerous because it can result in stack overruns.  Don't use recursion, unless you can clearly highlight the recursion and 
prove to the reader of your code that the recursion will be bounded well within the limits of even the smallest stack space that could reasonably be allocated to your thread.

@section cstdsGotos Gotos

@b goto statements should not be used.  If they are used, they must be used sparingly as a jump-to-exception-handling mechanism.

@code


{
    Rec_t* recPtr = CreateRec();

    ...

    if (x > LIMIT)
    {
        goto fault;
    }

    ...

    SaveRec(recPtr);
    return SUCCESS;

fault:

    ReleaseRec(recPtr);
    return FAILED;
}


@endcode

@section cstdsGlobalVariables Global Variables

Global variables are variables that are exported to other modules (i.e., have a scope that spans multiple files).

Global variables are dangerous because:

 * they don't allow protections from multithreaded race conditions,
 * they reduce maintainability by increasing coupling.

Globals must not be used.  Use accessor functions instead.

NOTE: file-scope static variables are fine.

@section cstdsExtern Extern

When global variables are not used and all inter-module interfaces are defined in header files, the "extern" keyword is not needed.  Don't use it.  
Use of "extern" is an indication of poor coding practices.

@section cstdsHeap Heap

Depending on the algorithm used, dynamic memory allocation using a memory heap (i.e., using malloc, free, and variants of malloc, such as calloc, realloc, and strdup) 
can lead to heap fragmentation, resulting in unexpected runtime failures.  Furthermore, heap allocation and deallocation can be very slow in some cases.

Use memory pools instead.  Memory pools eliminate internal fragmentation, run in O(1) time (for both allocation and deallocation), can be named for diagnostics purposes, 
allow finer-grained memory allocation statistics collection, and can provide OO constructor and destructor functionality.


@section cstdsMultipleInclusionGuards Multiple Inclusion Guards

In order to prevent multiple declaration errors due to multiple inclusion of the same header file, every header file must include a "multiple inclusion guard" of this form:

@code

#ifndef UNIQUE_INCLUDE_GUARD
#define UNIQUE_INCLUDE_GUARD

...

#endif

@endcode

"UNIQUE_INCLUDE_GUARD" must be replaced with a macro name that is certain to be unique to this header file.  To ensure this uniqueness, the macro name should

- contain the name of the file (converted to all upper case, with underscores separating words),
- be prefixed with a name or abbreviation that is unique to the module that the header file is a part of,
 - have "_INCLUDE_GUARD" as a suffix.

For example, the "Converter" module's inter-module interface file "'''converter.h'''" in the Sierra Wireless ('''SWI''') "'''Transmogrifier'''" component could contain a multiple inclusion guard macro named like this:
@code

SWI_TMOG_CONVERTER_INCLUDE_GUARD

@endcode

No code (other than comments) in a header file may reside outside of that file's multiple inclusion guard.

For example,
@code

// Only comments allowed here.

#ifndef SWI_TMOG_CONVERTER_INCLUDE_GUARD
#define SWI_TMOG_CONVERTER_INCLUDE_GUARD

// Any code can go here.

#endif // SWI_TMOG_CONVERTER_INCLUDE_GUARD

// Only comments allowed here, but preferably nothing but the end of file should be here.

@endcode

To allow these include guard macros to be renamed (in case the file is renamed, the code changes hands, a naming conflict is found, etc.) and to avoid confusing future maintainers, 
these macros should not be used for anything else other than the multiple inclusion guard.

NOTE: when modifying pre-existing code that contains multiple-inclusion guards, use the multiple-inclusion guard style of the pre-existing code, rather than using our style of multiple-inclusion guard.

@section cstdsLineLength Line Length

Lines of code should not be longer than 100 columns.

@section cstdsExistingCode Existing Code

When modifying pre-existing code, the style of the pre-existing code should be used over any of the standards listed below.  However, even when modifying pre-existing code, 
the '''standards listed above still apply''' to those parts that you modify.  Although, you would not be expected to rewrite a complex pre-existing function just because you made a very small change to it.


@section cstdsNaming Naming

Naming is arguably one of the most important aspects of coding.  The impact that naming has on readability (and therefore reviewability and maintainability) cannot be understated.  
Extra time spent on choosing the right names or correcting poor naming is almost certainly going to pay back several times over in future savings of time and effort in peer reviews, 
testing, troubleshooting, and renovations (refactoring, re-engineering, and design and implementation of new requirements).

<b>Be Descriptive</b>

The most important requirement for names of identifiers, files, etc. is that they '''describe what they are'''.  Don't call a pointer to a timer "p", or "tp" (is that toilet paper?).
 Call it "timerPtr".  At a glance, it's extremely obvious what a "timerPtr" is.

It is, however, acceptable for loop counters to be numbered simply "i" (or "j" for a nested loop, or "k" for a nested nested loop), 
because these are common usages, not only in programming, but also in mathematics.

It is also acceptable for variables with ''very'' limited scope (i.e., limited to a handful of lines of code) to have very simplified names, 
if that improves readability through the reduction of clutter.  For example, "t" becomes more acceptable for a timer reference if it's used in a tiny code block like this:
@code

static void StartTimer(void)
{
    le_timer_Ref_t t = le_timer_Create(TimerPool);
    le_timer_SetInterval(t, TIMER_INTERVAL);
    le_timer_SetExpiryHandler(t, TimerExpired, NULL);
    le_timer_Start(t);
}

@endcode

@section cstdsPrefixesOverview Prefixes Overview 

Often, an identifier prefix is needed to prevent naming conflicts between identifiers that are exported to other modules as a part of an interface.  For example, two interfaces may each define a function called "GetSize".  To prevent naming conflicts (and to avoid programmer confusion), each of those interfaces prefixes its "GetSize" function identifier with its own, unique prefix. Of course, these prefixes are also needed for other things besides functions: types, variables, files, and macros.  This section defines the general structure of these prefixes, while other sections define the specific prefixing rules for types, variables, functions, etc.

The structure of an interface-specific prefix differs based on the scope of the interface.  The possible scopes are:

 * ''inter-component'' - an interface implemented by one component and used by other components
 * ''inter-module'' - and interface implemented by one module and used by other modules ''within the same component''.

Note that inter-module interfaces could also be called ''intra''-component interfaces, but "intra" looks and sounds too much like "inter", so "inter-module" is the preferred term.

Each part of the prefix '''must start with a lower case letter''' (unless it is a [[#Macros|macro]] prefix) and must be '''separated from other parts of the identifier using underscores'''.

Underscores are used instead of capitalization to separate the parts of the prefix and to separate the prefix from the identifier for several reasons:

To make the prefix visibly stand out clearly from the rest of the identifier. 
Because abbreviations tend to often be acronyms, which sometimes get capitalized improperly when using camel case. 
To make machine parsing of these identifiers easier.

@section cstdsInterComponentInterfaces Component Interfaces

'''Inter-component interfaces''' have prefixes containing at least two parts:

 * company abbreviation
 * interface name abbreviation

The '''company abbreviation''' indicates what company the interface belongs to.  For interfaces owned by Sierra Wireless, this could be "swi". 
For open-source projects, the abbreviation would indicate which project the interface belongs to.  For example, interfaces defined as part of the "Legato" 
project could start with "le_".

The '''interface name abbreviation''' is simply an abbreviation of the interface's name.  For example, a "memory management API" might have "mem" as its abbreviation.  
This abbreviation should not be longer than 5 characters.  Two to four characters is preferred.

So, for example, a timer API owned by Sierra Wireless might have the prefix "swi_tmr_",

@code

typedef struct swi_tmr* swi_tmr_Ref_t;

swi_tmr_Ref_t swi_tmr_Create(void);
void swi_tmr_SetInterval(swi_tmr_Ref_t timer, uint intervalInMs);
void swi_tmr_Start(swi_tmr_Ref_t timer);
...

while the Legato Memory Management API could have the prefix "le_mem_".


typedef struct le_mem_Pool* le_mem_PoolRef_t;

le_mem_PoolRef_t le_mem_CreatePool(size_t blockSizeInBytes);

@endcode

@section cstdsInterModuleInterfaces Module Interfaces

'''Inter-module interfaces''' have only one part to their prefix: an interface name abbreviation.  For example, a "Registration List" module may use the 
prefix "rlist_", while a "Registration" module, which implements the Registration objects that get stored in the Registration List might use the prefix "reg_":


void rlist_Add(reg_Ref_t registration);
void rlist_Remove(reg_Ref_t registration);
reg_Ref_t rlist_FindByName(const char* name);

Because inter-module interfaces are not seen outside of the component in which they are defined, it is impossible to have a naming conflict between an inter-module 
interface in one component and an inter-module interface in another component (Actually, there could still be a conflict at the link stage, if the symbols are allowed to leak out, 
but a linker script file can be used to prevent this quite easily).  Furthermore, because all interfaces imported from outside a component will have both a company prefix and 
an interface name abbreviation, it is impossible to have a naming conflict between an inter-component interface and an inter-module interface.  
The difference in the prefixes also highlights the scope differences of the identifiers, which can be significant to those who have to read the code someday: 
someone looking at a piece of code can easily see whether there is coupling with other components or just other modules within the same component.

@section cstdsFiles Files

As with other forms of identifiers, the most important requirement for file names is that they '''must be descriptive'''.  I.e., the name of the file must clearly describe what the file contains.

Also important, however, is that files must be named in such a way that their '''names will not conflict''' with the names of other files.  This is mainly important for include files.  
For example, don't call one of your header files "time.h", because that name will conflict with the C standard library file of the same name.  To this end, '''inter-component interface''' 
headers must be prefixed with the '''company abbreviation''' [[#CompanyAbbreviation|as described above]].  (For example, the Sierra Wireless "Transmogrifier" API include file could be 
named something like "swi_transmog.h".)  But, prefixes are not required on files that are only visible within a limited scope (e.g., implementation files or inter-module interfaces only 
visible inside a single software component).

@section cstdsMacros Macros

Macros can be used in similar ways to variables and functions, but their behaviour has subtle differences that can result in bugs or code bloat if used incorrectly.  
Compiler errors and warnings resulting from macro substitution can also be somewhat cryptic and difficult to understand if it isn't obvious that the code involved is a macro. 
 Therefore, it is important to be able to easily distinguish visually a macro from a non-macro when reading code.  To this end, macro names must be '''all uppercase''', 
 with words separated using '''underscores'''.

Names of macros can also conflict with the names of macros defined in include files from other modules.  To reduce the chances of a naming conflict, 
any '''macros exported to other modules must have a prefix''', and even macros only used within a single file should have a prefix if the names are likely to conflict with 
names defined in standard C libraries and other included code that doesn't use prefixes.  Prefix rules are [[#Prefixes|defined above]].



@section cstdsNameSuffix Suffix Name

Types are distinctly different from instances, and yet it is possible to name them such that it can be hard to tell whether something is a type or a variable when reading the code.  
And naming conflicts can occur between types and variables and even between types and functions.  To prevent these sorts of issues, type names are always given an '''"_t" suffix'''.

@section cstdsNamePrefix Name Prefix

If a type is defined in a header file, there's the possibility that its name may conflict with the name of another type defined elsewhere.  
To prevent such conflicts, all types that are defined '''inside header files must have a prefix''' 

Types that are defined inside implementation (.c) files don't need such a prefix.  They have file scope, and imported types will have prefixes, so naming conflicts are highly unlikely.

The prefix (if any) must be all lower-case.

@section cstdsNameType Name Type

After the prefix (if any), the rest of the type name must be in CamelCase, beginning with an uppercase character.
@code

// Inside a .c file:
typedef size_t ObjectCount_t;



// Inside the Sierra Wireless "Foo" component's API .h file:
typedef size_t swi_foo_ObjectCount_t;

@endcode

@section cstdsCardinalTypes Cardinal Types

Cardinal types (e.g., int, uint, int32, bool) are exempt from having a prefix or suffix because

 a. naming a variable "bool" or "int" would not be very descriptive, so there's little point in trying to avoid such naming conflicts.
 a. most cardinal types are built into the language and we are not allowed to change their names (nor would we want to -- imagine the confusion and the 3rd-party integration problems!).

@section cstdsEnumerationMembers Enumeration Members

Enumeration members are constants that are used in a very similar way to macro constants.  To clearly identify them as literal constants, they must be named 
using '''all upper-case with underscores separating words'''.

Also like macros, names of enumeration members can also conflict with the names of macros and enumeration members defined in include files from other modules.  
To reduce the chances of a naming conflict, any '''members of enumerations exported to other modules must have a prefix''', and even members of enumerations only 
used within a single file should have a prefix if the names are likely to conflict with names defined in standard C libraries and other included code that doesn't use prefixes. 

@section cstdsStructandUnionNamespaces Struct and Union Namespaces

When a structure or union is defined, it's possible to give a name to that structure or union within a separate namespace. In the following example, "MessageBody" and "Message" are in the union and struct namespaces, but "MessageBody_t" and "Message_t" are not:

@code

typedef union MessageBody
{
    Request_t request;
    Response_t response;
}
MessageBody_t;

typedef struct Message
{
    MessageType_t type;
    MessageBody_t body;
}
Message_t;

@endcode

All uses of a name in the struct namespace must be preceded by the keyword "struct".  Likewise, all uses of a name in the union namespace must be preceded by the keyword "union".  Because these identifiers always appear with "struct" or "union" right before them, there is no confusion as to whether they are types, variables or functions; and because they are in a separate namespace, there's no possibility of naming conflicts with identifiers outside of the struct and union namespaces.  Therefore, these names are '''exempt from having an "_t" suffix'''.  However, if these are defined in a header file, they still must have a prefix to prevent naming conflicts with other identifiers defined by other components in the same namespace.

@section cstdsStructandUnionMembers Struct and Union Members

The names of members of structures and unions must start with a lower-case letter and use camel case to separate words.

Because structure and union member names are always used in context (in a dereference expression), there is no confusing them with other types' members (assuming the structure or union reference identifier is well named).  Therefore, no prefix is needed on structure or union member names.

For example,
@code

typedef struct
{
    char* textBufferPtr;
    int   textLength;

    ...
}
MyStructure_t;

static void PrintTextBuffer(MyStructure_t* objectPtr)
{
    int i;
    for (i = 0; i < objectPtr->textLength; i++)
    {
        PrintChar(objectPtr->textBufferPtr[i]);
    }
}

@endcode
Note: Only stack variable names and struct/union member names can (and must) start with lower-case letters.


@section cstdsPrefix Prefix

If a function is defined in a header file, there's the possibility that its name may conflict with the name of another function defined elsewhere.  To prevent such conflicts, all functions defined '''inside header files must have a prefix'''

Functions that are defined inside implementation (.c) files don't need an inter-component or inter-module prefix. 
Functions defined inside .c files have file scope and any imported functions will have inter-component or inter-module prefixes, so naming conflicts are highly unlikely.

In addition, if a function belongs to a specific type of object (i.e., class) in an object oriented interface, its prefix must have an additional object name part. 
The object name part of a prefix must start with a lowercase letter and must be separated from other parts of the identifier using underscores. 
If the object name is made up of multiple words, they must be separated using capitalization of the first letter of the second and subsequent words in the object name 
(e.g., ipRoute or simCard).

@code

pool = le_mem_CreatePool(sizeof(MyObject_t), "My objects");  // This function doesn't belong to a class.
le_mem_pool_Expand(pool, numObjects);  // This is one of the "pool" class's functions.
objPtr = le_mem_pool_Alloc(pool); // This also belongs to the "pool" class.
objSize = le_mem_block_GetSize(objPtr);  // This function belongs to the "block" class.

@endcode

@section cstdsCamelCaseName Camel Case Name

After the prefix (if any), the rest of the function name should be in CamelCase, starting with an uppercase letter.

@section cstdsVerbage  Verbage

Function names '''must contain a verb''', because they are active.  They should also contain an object, unless the object is obvious in the prefix.

To be consistent with Java conventions, the '''verb should come before the object'''.

Examples are: 

@code
GetTimeRemaining(), le_mem_CreatePool(), and swi_timer_Start().
@endcode


<HR>

Copyright (C) Sierra Wireless, Inc. 2014. All rights reserved. Use of this work is subject to license.

**/
