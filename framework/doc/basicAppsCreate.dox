/** @page basicAppsCreate Create Apps

These are the basic steps to build an app written in C that
logs <c>Hello World.</c> when the process it's in starts up:

 - @ref basicAppsCreate_component
 - @ref basicAppsCreate_adef
 - @ref basicAppsCreate_buildApp
 - @ref basicAppsCreate_instTarget
 - @ref basicAppsCreate_usage "Use App"

Then you're ready for the next level: @ref basicAppsAddThings, @ref basicAppsIPC, and
@ref basicAppsCompMulti.

@section basicAppsCreate_sampleDir Sample Directories and Files

Typical apps have directories and files that look this:
@verbatim
helloWorld/
├── helloComp
│   ├── Component.cdef
│   └── hello.c
└── helloWorld.adef
@endverbatim

@section basicAppsCreate_component Create Component
Complete these steps to create a component: @ref basicAppsCreate_componentCreateDir,
@ref basicAppsCreate_componentC, and @ref basicAppsCreate_componentCdef

@subsection basicAppsCreate_componentCreateDir Create Directory

@c 1. Create a directory: the directory name will become the component name:

@code
$ mkdir helloComp
@endcode

@subsection basicAppsCreate_componentC Create C Source File

@c 2. Create source (implementation) file @c hello.c:

@code
$ gedit helloComp/hello.c
@endcode

It should contain the following:

@code

#include "legato.h"

COMPONENT_INIT
{
    LE_INFO("Hello world.\n");
}

@endcode

This looks similar to the original C @c hello, world program from Kernighan's and Richie's
"The C Programming Language", except that:
 - \#include <stdio.h> is replaced with \#include "legato.h"
 - main() is replaced with COMPONENT_INIT

In fact, legato.h will include stdio.h, along with a bunch of other system headers and
Legato framework headers. This reduces the amount of time you have to spend including
header files to get access to the functions and data types you need.

The build tools figure out what language the source code is written in by looking at the
filename extension.  So, because our file @c hello.c ends in @c .c, the build tools will try to use
a C compiler to compile it into a library when it gets included in an executable.

@subsubsection basicAppsCreate_componentInit Component Initializer

The @c COMPONENT_INIT macro is used to identify your <b> component initializer</b>.
Every component must have a component initializer.

By using component initializers instead of having each component implement their own main()
function, it's possible to run multiple components in the same executable and even share
a thread between those components.

The main process thread  (the main() function auto-generated by the build tools)
will automatically call the component's initializer at the appropriate time during the process
start-up sequence (based on the inter-dependencies between components). If component A
is used by component B, then component A's initializer will be run before component B's initializer.
Then component B can safely call the API functions of component A knowing that component A
has already been initialized. This won't work if both components depend on each other (directly
or indirectly through other components). That's one reason why dependency loops are not permitted between
components. The framework will detect inter-component dependency loops at build time and
terminate the build.

Component initializers don't take any parameters and don't return anything, but they
<b> must always return </b> . Unless they experience a fatal error, in which case they <b> must
terminate the process </b> with a non-zero exit code (which can be done using @c LE_FATAL(),
@c LE_ASSERT(), etc. ).

@note If a component's initializer doesn't return, the process will not be able to finish
initializing all the components that have been deployed to it and the process's main thread
will never process any events that are queued to it.

In our "Hello World" example, we just use our component initializer to print @c Hello world to
the log using @c LE_INFO().

@subsection basicAppsCreate_componentCdef Create cdef File

@c 3. Create a @c cdef file called @c Component.cdef like this:

@code
$ gedit helloComp/Component.cdef
@endcode

@code
sources:
{
    hello.c
}
@endcode

See @ref defFiles for complete info.

@section basicAppsCreate_adef Create App

You need to create an @c adef file before you can build you app.

@c 4. Create an @c adef file called @c helloWorld.adef like this:

@code
executables:
{
    helloWorld = ( helloComp )
}

processes:
{
    run:
    {
        (helloWorld)
    }
}
@endcode

This defines one executable called @c helloWorld implemented by @c helloComp
and then starts one instance of the helloWorld executable.

If your executable has multiple components, add more components inside the
parentheses after the executable name: "helloWorld = ( helloComp foo bar )".

@section basicAppsCreate_buildApp Build App

@c 5. Run @c mkapp to build the executable and bundle it into an app:

Use the @c -t option to build for a target other than the default "localhost"
target.

This is how to build the helloWorld app to install on the
Sierra Wireless WP85 module:

@code
$ mkapp -t wp85 helloWorld.adef
@endcode

@note If you're building an AR7, substitute @c ar7 in the mkapp run command.

@section basicAppsCreate_instTarget Install App to Target

@c 6. Use @c instapp to install the app on your target:

@code
$ instapp helloWorld.wp85.update <ip addr>
@endcode

The second argument is the target device's IP address where to install the app.
This will connect to the target and install the app.

@section basicAppsCreate_usage Usage

These usage tips are based on running a secure shell (SSH) to interface with
the target. See <a href="http://www.mangoh.io/getting-started.html">mangoh.io</a> if you
need to setup your target device.

@subsection basicAppsCreate_usageLogin Target Login

Login to your target using a secure shell connection:

@code
$ ssh root@192.168.2.2
@endcode

@subsection basicAppsCreate_usageStartApp Target Start App

Start your application using the <code>app start</code> command:

@code
$ app start helloWorld
@endcode

@subsection basicAppsCreate_usageViewLogs View Logs

Your installed app's @c LE_INFO log message will appear in the system log ("syslog") on
the target device.

Run @c logread (on the target) to view the system log.

@code
# logread
@endcode

Use logread's @a -f option to start monitoring the logs and display messages as they are logged.

@code
# logread -f
@endcode

Here's a code sample accessing the logs on a target device with IP address 192.168.2.2 through an ssh connection:
@code
$ ssh root@192.168.2.2 '/sbin/logread -f'
@endcode

@subsection basicAppsCreate_usageRmApp Remove App

From the host PC, run @c rmapp to uninstall the app:

@code
$ rmapp helloWorld.wp85 <ip addr>
@endcode

From the target run:
@code
# app remove <app name>
@endcode

@subsection basicAppsCreate_usageLsApp List App

Use @c lsapp to list the apps installed on a target.

@code
$ lsapp <ip addr>
@endcode

<HR>

Copyright (C) Sierra Wireless Inc. Use of this work is subject to license.

**/
